"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkTslintJson = exports.isExternalDependency = exports.lint = void 0;
const typescript_versions_1 = require("@definitelytyped/typescript-versions");
const utils_1 = require("@definitelytyped/utils");
const assert = require("assert");
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const tslint_1 = require("tslint");
const eslint_1 = require("eslint");
const expectRule_1 = require("./rules/expectRule");
const util_1 = require("./util");
async function lint(dirPath, minVersion, maxVersion, isLatest, expectOnly, tsLocal) {
    const tsconfigPath = (0, path_1.join)(dirPath, "tsconfig.json");
    // TODO: To remove tslint, replace this with a ts.createProgram (probably)
    const lintProgram = tslint_1.Linter.createProgram(tsconfigPath);
    for (const version of [maxVersion, minVersion]) {
        const errors = testDependencies(version, dirPath, lintProgram, tsLocal);
        if (errors) {
            return errors;
        }
    }
    const linter = new tslint_1.Linter({ fix: false, formatter: "stylish" }, lintProgram);
    const configPath = expectOnly ? (0, path_1.join)(__dirname, "..", "dtslint-expect-only.json") : getConfigPath(dirPath);
    // TODO: To port expect-rule, eslint's config will also need to include [minVersion, maxVersion]
    //   Also: expect-rule should be renamed to expect-type or check-type or something
    const config = await getLintConfig(configPath, tsconfigPath, minVersion, maxVersion, tsLocal);
    const esfiles = [];
    for (const file of lintProgram.getSourceFiles()) {
        if (lintProgram.isSourceFileDefaultLibrary(file)) {
            continue;
        }
        const { fileName, text } = file;
        if (!fileName.includes("node_modules")) {
            const err = testNoTsIgnore(text) ||
                testNoLintDisables("tslint:disable", text) ||
                testNoLintDisables("eslint-disable", text);
            if (err) {
                const { pos, message } = err;
                const place = file.getLineAndCharacterOfPosition(pos);
                return `At ${fileName}:${JSON.stringify(place)}: ${message}`;
            }
        }
        // External dependencies should have been handled by `testDependencies`;
        // typesVersions should be handled in a separate lint
        if (!isExternalDependency(file, dirPath, lintProgram) && (!isLatest || !isTypesVersionPath(fileName, dirPath))) {
            linter.lint(fileName, text, config);
            esfiles.push(fileName);
        }
    }
    const result = linter.getResult();
    const cwd = process.cwd();
    process.chdir(dirPath);
    const eslint = new eslint_1.ESLint({
        rulePaths: [(0, path_1.join)(__dirname, "./rules/")],
    });
    const formatter = await eslint.loadFormatter("stylish");
    const eresults = await eslint.lintFiles(esfiles);
    process.chdir(cwd);
    let output;
    if (result.failures.length)
        output = result.output;
    output = (output || "") + formatter.format(eresults);
    return output;
}
exports.lint = lint;
function testDependencies(version, dirPath, lintProgram, tsLocal) {
    const tsconfigPath = (0, path_1.join)(dirPath, "tsconfig.json");
    assert(version !== "local" || tsLocal);
    const ts = require((0, utils_1.typeScriptPath)(version, tsLocal));
    const program = (0, expectRule_1.getProgram)(tsconfigPath, ts, version, lintProgram);
    const diagnostics = ts
        .getPreEmitDiagnostics(program)
        .filter((d) => !d.file || isExternalDependency(d.file, dirPath, program));
    if (!diagnostics.length) {
        return undefined;
    }
    const showDiags = ts.formatDiagnostics(diagnostics, {
        getCanonicalFileName: (f) => f,
        getCurrentDirectory: () => dirPath,
        getNewLine: () => "\n",
    });
    const message = `Errors in typescript@${version} for external dependencies:\n${showDiags}`;
    // Add an edge-case for someone needing to `npm install` in react when they first edit a DT module which depends on it - #226
    const cannotFindDepsDiags = diagnostics.find((d) => d.code === 2307 && d.messageText.toString().includes("Cannot find module"));
    if (cannotFindDepsDiags && cannotFindDepsDiags.file) {
        const path = cannotFindDepsDiags.file.fileName;
        const typesFolder = (0, path_1.dirname)(path);
        return `
A module look-up failed, this often occurs when you need to run \`npm install\` on a dependent module before you can lint.

Before you debug, first try running:

   npm install --prefix ${typesFolder}

Then re-run. Full error logs are below.

${message}`;
    }
    else {
        return message;
    }
}
function isExternalDependency(file, dirPath, program) {
    return !startsWithDirectory(file.fileName, dirPath) || program.isSourceFileFromExternalLibrary(file);
}
exports.isExternalDependency = isExternalDependency;
function normalizePath(file) {
    // replaces '\' with '/' and forces all DOS drive letters to be upper-case
    return (0, path_1.normalize)(file)
        .replace(/\\/g, "/")
        .replace(/^[a-z](?=:)/, (c) => c.toUpperCase());
}
function isTypesVersionPath(fileName, dirPath) {
    const normalFileName = normalizePath(fileName);
    const normalDirPath = normalizePath(dirPath);
    const subdirPath = (0, util_1.withoutPrefix)(normalFileName, normalDirPath);
    return subdirPath && /^\/ts\d+\.\d/.test(subdirPath);
}
function startsWithDirectory(filePath, dirPath) {
    const normalFilePath = normalizePath(filePath);
    const normalDirPath = normalizePath(dirPath).replace(/\/$/, "");
    return normalFilePath.startsWith(normalDirPath + "/") || normalFilePath.startsWith(normalDirPath + "\\");
}
function testNoTsIgnore(text) {
    const tsIgnore = "ts-ignore";
    const pos = text.indexOf(tsIgnore);
    return pos === -1 ? undefined : { pos, message: "'ts-ignore' is forbidden." };
}
function testNoLintDisables(disabler, text) {
    let lastIndex = 0;
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const pos = text.indexOf(disabler, lastIndex);
        if (pos === -1) {
            return undefined;
        }
        const end = pos + disabler.length;
        const nextChar = text.charAt(end);
        const nextChar2 = text.charAt(end + 1);
        if (nextChar !== "-" &&
            !(disabler === "tslint:disable" && nextChar === ":") &&
            !(disabler === "eslint-disable" && nextChar === " " && nextChar2 !== "*")) {
            const message = `'${disabler}' is forbidden. ` +
                "Per-line and per-rule disabling is allowed, for example: " +
                "'tslint:disable:rulename', tslint:disable-line' and 'tslint:disable-next-line' are allowed.";
            return { pos, message };
        }
        lastIndex = end;
    }
}
async function checkTslintJson(dirPath, dt) {
    const configPath = getConfigPath(dirPath);
    const shouldExtend = `@definitelytyped/dtslint/${dt ? "dt" : "dtslint"}.json`;
    const validateExtends = (extend) => extend === shouldExtend || (!dt && Array.isArray(extend) && extend.some((val) => val === shouldExtend));
    if (!(await (0, fs_extra_1.pathExists)(configPath))) {
        if (dt) {
            throw new Error(`On DefinitelyTyped, must include \`tslint.json\` containing \`{ "extends": "${shouldExtend}" }\`.\n` +
                "This was inferred as a DefinitelyTyped package because it contains a `// Type definitions for` header.");
        }
        return;
    }
    const tslintJson = await (0, util_1.readJson)(configPath);
    if (!validateExtends(tslintJson.extends)) {
        throw new Error(`If 'tslint.json' is present, it should extend "${shouldExtend}"`);
    }
}
exports.checkTslintJson = checkTslintJson;
function getConfigPath(dirPath) {
    return (0, path_1.join)(dirPath, "tslint.json");
}
async function getLintConfig(expectedConfigPath, tsconfigPath, minVersion, maxVersion, tsLocal) {
    const configExists = await (0, fs_extra_1.pathExists)(expectedConfigPath);
    const configPath = configExists ? expectedConfigPath : (0, path_1.join)(__dirname, "..", "dtslint.json");
    // Second param to `findConfiguration` doesn't matter, since config path is provided.
    const config = tslint_1.Configuration.findConfiguration(configPath, "").results;
    if (!config) {
        throw new Error(`Could not load config at ${configPath}`);
    }
    const expectRule = config.rules.get("expect");
    if (!expectRule || expectRule.ruleSeverity !== "error") {
        throw new Error("'expect' rule should be enabled, else compile errors are ignored");
    }
    if (expectRule) {
        const versionsToTest = range(minVersion, maxVersion).map((versionName) => ({
            versionName,
            path: (0, utils_1.typeScriptPath)(versionName, tsLocal),
        }));
        const expectOptions = { tsconfigPath, versionsToTest };
        expectRule.ruleArguments = [expectOptions];
    }
    return config;
}
function range(minVersion, maxVersion) {
    if (minVersion === "local") {
        assert(maxVersion === "local");
        return ["local"];
    }
    if (minVersion === typescript_versions_1.TypeScriptVersion.latest) {
        assert(maxVersion === typescript_versions_1.TypeScriptVersion.latest);
        return [typescript_versions_1.TypeScriptVersion.latest];
    }
    assert(maxVersion !== "local");
    const minIdx = typescript_versions_1.TypeScriptVersion.shipped.indexOf(minVersion);
    assert(minIdx >= 0);
    if (maxVersion === typescript_versions_1.TypeScriptVersion.latest) {
        return [...typescript_versions_1.TypeScriptVersion.shipped.slice(minIdx), typescript_versions_1.TypeScriptVersion.latest];
    }
    const maxIdx = typescript_versions_1.TypeScriptVersion.shipped.indexOf(maxVersion);
    assert(maxIdx >= minIdx);
    return typescript_versions_1.TypeScriptVersion.shipped.slice(minIdx, maxIdx + 1);
}
//# sourceMappingURL=lint.js.map
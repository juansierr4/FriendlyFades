/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NodeEventGenerator = void 0;

var _hermesParser = require("hermes-parser");

var esquery = _interopRequireWildcard(require("./esquery"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const ESQUERY_OPTIONS = Object.freeze({
  visitorKeys: _hermesParser.FlowVisitorKeys,
  fallback: node => {
    throw new Error(`No visitor keys found for node type "${node.type}".`);
  }
});
/**
 * Computes the union of one or more arrays
 * @param arrays One or more arrays to union
 * @returns The union of the input arrays
 */

function union(...arrays) {
  return [...new Set(arrays.flat())];
}
/**
 * Computes the intersection of one or more arrays
 * @param arrays One or more arrays to intersect
 * @returns The intersection of the input arrays
 */


function intersection(...arrays) {
  if (arrays.length === 0) {
    return [];
  }

  let result = [...new Set(arrays[0])];

  for (const array of arrays.slice(1)) {
    result = result.filter(x => array.includes(x));
  }

  return result;
}
/**
 * Gets the possible types of a selector
 * @param parsedSelector An object (from esquery) describing the matching behavior of the selector
 * @returns The node types that could possibly trigger this selector, or `null` if all node types could trigger it
 */


function getPossibleTypes(parsedSelector) {
  switch (parsedSelector.type) {
    case 'identifier':
      if (!(parsedSelector.value in _hermesParser.FlowVisitorKeys)) {
        throw new Error(`Unexpected selector ${parsedSelector.value}`);
      } // $FlowExpectedError[incompatible-return]


      return [parsedSelector.value];

    case 'matches':
      {
        const typesForComponents = parsedSelector.selectors.map(getPossibleTypes);
        const typesForComponentsNonNull = typesForComponents.filter(Boolean);

        if (typesForComponents.length === typesForComponentsNonNull.length) {
          return union(...typesForComponentsNonNull);
        }

        return null;
      }

    case 'compound':
      {
        const typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter(Boolean); // If all of the components could match any type, then the compound could also match any type.

        if (!typesForComponents.length) {
          return null;
        }
        /*
         * If at least one of the components could only match a particular type, the compound could only match
         * the intersection of those types.
         */


        return intersection(...typesForComponents);
      }

    case 'child':
    case 'descendant':
    case 'sibling':
    case 'adjacent':
      return getPossibleTypes(parsedSelector.right);

    case 'class':
      if (parsedSelector.name === 'function') {
        return ['FunctionDeclaration', 'FunctionExpression', 'ArrowFunctionExpression'];
      }

      return null;

    default:
      return null;
  }
}
/**
 * Counts the number of class, pseudo-class, and attribute queries in this selector
 * @param parsedSelector An object (from esquery) describing the selector's matching behavior
 * @returns The number of class, pseudo-class, and attribute queries in this selector
 */


function countClassAttributes(parsedSelector) {
  switch (parsedSelector.type) {
    case 'child':
    case 'descendant':
    case 'sibling':
    case 'adjacent':
      return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);

    case 'compound':
    case 'not':
    case 'matches':
      return parsedSelector.selectors.reduce((sum, childSelector) => sum + countClassAttributes(childSelector), 0);

    case 'attribute':
    case 'field':
    case 'nth-child':
    case 'nth-last-child':
      return 1;

    default:
      return 0;
  }
}
/**
 * Counts the number of identifier queries in this selector
 * @param parsedSelector An object (from esquery) describing the selector's matching behavior
 * @returns The number of identifier queries
 */


function countIdentifiers(parsedSelector) {
  switch (parsedSelector.type) {
    case 'child':
    case 'descendant':
    case 'sibling':
    case 'adjacent':
      return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);

    case 'compound':
    case 'not':
    case 'matches':
      return parsedSelector.selectors.reduce((sum, childSelector) => sum + countIdentifiers(childSelector), 0);

    case 'identifier':
      return 1;

    default:
      return 0;
  }
}
/**
 * Compares the specificity of two selector objects, with CSS-like rules.
 * @param selectorA An AST selector descriptor
 * @param selectorB Another AST selector descriptor
 * @returns
 * a value less than 0 if selectorA is less specific than selectorB
 * a value greater than 0 if selectorA is more specific than selectorB
 * a value less than 0 if selectorA and selectorB have the same specificity, and selectorA <= selectorB alphabetically
 * a value greater than 0 if selectorA and selectorB have the same specificity, and selectorA > selectorB alphabetically
 */


function compareSpecificity(selectorA, selectorB) {
  return selectorA.attributeCount - selectorB.attributeCount || selectorA.identifierCount - selectorB.identifierCount || (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);
}
/**
 * Parses a raw selector string, and throws a useful error if parsing fails.
 * @param rawSelector A raw AST selector
 * @returns An object (from esquery) describing the matching behavior of this selector
 * @throws An error if the selector is invalid
 */


function tryParseSelector(rawSelector) {
  try {
    return esquery.parse(rawSelector.replace(/:exit$/u, ''));
  } catch (err) {
    if (err.location && err.location.start && typeof err.location.start.offset === 'number') {
      throw new SyntaxError(`Syntax error in selector "${rawSelector}" at position ${err.location.start.offset}: ${err.message}`);
    }

    throw err;
  }
}

const selectorCache = new Map();
/**
 * Parses a raw selector string, and returns the parsed selector along with specificity and type information.
 * @param rawSelector A raw AST selector
 * @returns A selector descriptor
 */

function parseSelector(rawSelector) {
  const cachedSelector = selectorCache.get(rawSelector);

  if (cachedSelector) {
    return cachedSelector;
  }

  const parsedSelector = tryParseSelector(rawSelector);
  const result = {
    rawSelector,
    isExit: rawSelector.endsWith(':exit'),
    parsedSelector,
    listenerTypes: getPossibleTypes(parsedSelector),
    attributeCount: countClassAttributes(parsedSelector),
    identifierCount: countIdentifiers(parsedSelector)
  };
  selectorCache.set(rawSelector, result);
  return result;
}
/**
 * The event generator for AST nodes.
 */


class NodeEventGenerator {
  /**
   * @param emitter
   * An SafeEmitter which is the destination of events. This emitter must already
   * have registered listeners for all of the events that it needs to listen for.
   * (See lib/linter/safe-emitter.js for more details on `SafeEmitter`.)
   */
  constructor(emitter) {
    this.emitter = void 0;
    this._currentAncestry = [];
    this._enterSelectorsByNodeType = new Map();
    this._exitSelectorsByNodeType = new Map();
    this._anyTypeEnterSelectors = [];
    this._anyTypeExitSelectors = [];
    this.emitter = emitter;
    emitter.eventNames().forEach(rawSelector => {
      const selector = parseSelector(rawSelector);

      if (selector.listenerTypes) {
        const typeMap = selector.isExit ? this._exitSelectorsByNodeType : this._enterSelectorsByNodeType;
        selector.listenerTypes.forEach(nodeType => {
          const selectors = typeMap.get(nodeType);

          if (!selectors) {
            typeMap.set(nodeType, [selector]);
          } else {
            selectors.push(selector);
          }
        });
      } else {
        const selectors = selector.isExit ? this._anyTypeExitSelectors : this._anyTypeEnterSelectors;
        selectors.push(selector);
      }
    });

    this._anyTypeEnterSelectors.sort(compareSpecificity);

    this._anyTypeExitSelectors.sort(compareSpecificity);

    this._enterSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));

    this._exitSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));
  }
  /**
   * Checks a selector against a node, and emits it if it matches
   * @param node The node to check
   * @param selector An AST selector descriptor
   * @private
   */


  _applySelector(node, selector) {
    if (esquery.matches(node, selector.parsedSelector, this._currentAncestry, ESQUERY_OPTIONS)) {
      this.emitter.emit(selector.rawSelector, node);
    }
  }
  /**
   * Applies all appropriate selectors to a node, in specificity order
   * @param node The node to check
   * @param isExit `false` if the node is currently being entered, `true` if it's currently being exited
   * @private
   */


  _applySelectors(node, isExit) {
    const selectorsByNodeType = (isExit ? this._exitSelectorsByNodeType : this._enterSelectorsByNodeType).get(node.type) || [];
    const anyTypeSelectors = isExit ? this._anyTypeExitSelectors : this._anyTypeEnterSelectors;
    /*
     * selectorsByNodeType and anyTypeSelectors were already sorted by specificity in the constructor.
     * Iterate through each of them, applying selectors in the right order.
     */

    let selectorsByTypeIndex = 0;
    let anyTypeSelectorsIndex = 0;

    while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {
      if (selectorsByTypeIndex >= selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length && compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0) {
        this._applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);
      } else {
        this._applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);
      }
    }
  }
  /**
   * Emits an event of entering AST node.
   * @param node A node which was entered.
   */


  enterNode(node) {
    this._applySelectors(node, false);

    this._currentAncestry.unshift(node);
  }
  /**
   * Emits an event of leaving AST node.
   * @param node A node which was left.
   */


  leaveNode(node) {
    this._currentAncestry.shift();

    this._applySelectors(node, true);
  }

}

exports.NodeEventGenerator = NodeEventGenerator;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.traverse = traverse;
exports.traverseWithContext = traverseWithContext;

var _codeFrame = require("@babel/code-frame");

var _NodeEventGenerator = require("./NodeEventGenerator");

var _SafeEmitter = require("./SafeEmitter");

var _hermesParser = require("hermes-parser");

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

/**
 * Traverse the AST with additional context members provided by `additionalContext`.
 * @param ast the ESTree AST to traverse
 * @param scopeManager the eslint-scope compatible scope manager instance calculated using the ast
 * @param additionalContext a callback function which returns additional context members to add to the context provided to the visitor
 */
function traverseWithContext(code, ast, scopeManager, additionalContext, visitor) {
  const emitter = new _SafeEmitter.SafeEmitter();
  let currentNode = ast;
  let shouldSkipTraversal = false;
  let shouldStopTraversal = false;

  const getScope = (givenNode = currentNode) => {
    // On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.
    const inner = givenNode.type !== 'Program';

    for (let node = givenNode; node; node = node.parent) {
      const scope = scopeManager.acquire(node, inner);

      if (scope) {
        if (scope.type === 'function-expression-name') {
          return scope.childScopes[0];
        }

        return scope;
      }
    }

    return scopeManager.scopes[0];
  };

  const traversalContextBase = Object.freeze({
    buildCodeFrame: (node, message) => {
      // babel uses 1-indexed columns
      const locForBabel = {
        start: {
          line: node.loc.start.line,
          column: node.loc.start.column + 1
        },
        end: {
          line: node.loc.end.line,
          column: node.loc.end.column + 1
        }
      };
      return (0, _codeFrame.codeFrameColumns)(code, locForBabel, {
        linesAbove: 0,
        linesBelow: 0,
        highlightCode: process.env.NODE_ENV !== 'test',
        message: message
      });
    },
    buildSimpleCodeFrame: (node, message) => {
      return `[${node.type}:${node.loc.start.line}:${node.loc.start.column}] ${message}`;
    },
    getDeclaredVariables: node => scopeManager.getDeclaredVariables(node),
    getBinding: name => {
      let currentScope = getScope();

      while (currentScope != null) {
        for (const variable of currentScope.variables) {
          if (variable.defs.length && variable.name === name) {
            return variable;
          }
        }

        currentScope = currentScope.upper;
      }

      return null;
    },
    getScope,
    stopTraversal: () => {
      shouldStopTraversal = true;
    },
    skipTraversal: () => {
      shouldSkipTraversal = true;
    }
  });
  const traversalContext = Object.freeze({ ...traversalContextBase,
    ...additionalContext(traversalContextBase)
  });
  const selectors = visitor(traversalContext); // add all the selectors from the visitor as listeners

  Object.keys(selectors).forEach(selector => {
    // flow doesn't want us to be general here - but it's safe
    // $FlowExpectedError[incompatible-type]
    // $FlowExpectedError[prop-missing]
    const listener = selectors[selector];

    if (listener) {
      emitter.on(selector, listener);
    }
  });
  const eventGenerator = new _NodeEventGenerator.NodeEventGenerator(emitter);

  function checkTraversalFlags() {
    if (shouldStopTraversal) {
      // No need to reset the flag since we won't enter any more nodes.
      throw _hermesParser.SimpleTraverser.Break;
    }

    if (shouldSkipTraversal) {
      shouldSkipTraversal = false;
      throw _hermesParser.SimpleTraverser.Skip;
    }
  }

  _hermesParser.SimpleTraverser.traverse(ast, {
    enter(node) {
      currentNode = node;
      eventGenerator.enterNode(node);
      checkTraversalFlags();
    },

    leave(node) {
      currentNode = node;
      eventGenerator.leaveNode(node);
      checkTraversalFlags();
    }

  });
}

function traverse(code, ast, scopeManager, visitor) {
  traverseWithContext(code, ast, scopeManager, () => {}, visitor);
}
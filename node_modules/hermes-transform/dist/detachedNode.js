"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.asDetachedNode = void 0;
exports.asDetachedNodeForCodeGen = asDetachedNodeForCodeGen;
exports.deepCloneNode = deepCloneNode;
exports.detachedProps = detachedProps;
exports.getOriginalNode = getOriginalNode;
exports.isDetachedNode = isDetachedNode;
exports.setParentPointersInDirectChildren = setParentPointersInDirectChildren;
exports.shallowCloneNode = shallowCloneNode;
exports.updateAllParentPointers = updateAllParentPointers;

var _hermesParser = require("hermes-parser");

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
const DETACHED_MARKER = Symbol.for('hermes-transform - Detached AST Node');
const ORIGINAL_NODE = Symbol.for('hermes-transform - Original Node');

function isDetachedNode(node) {
  // $FlowExpectedError[invalid-in-lhs] flow doesn't support symbols as keys
  return DETACHED_MARKER in node;
}

function getOriginalNode(node) {
  // $FlowExpectedError[prop-missing]
  return node[ORIGINAL_NODE];
}
/* $FlowExpectedError[unclear-type] Type safety is not needed for generated
 * code, this avoids us always having to pass a generic property within codegen */


function asDetachedNodeForCodeGen(node) {
  if (node == null) {
    return null;
  }

  if (isDetachedNode(node)) {
    return node;
  }

  return shallowCloneNode(node, {});
}

const asDetachedNode = (node, {
  useDeepClone
} = {
  useDeepClone: false
}) => {
  if (node == null) {
    return null;
  }

  if (isDetachedNode(node)) {
    return node;
  }

  return useDeepClone ? deepCloneNode(node, {}) : shallowCloneNode(node, {});
}; // used by the node type function codegen


exports.asDetachedNode = asDetachedNode;

function detachedProps(parent, props, config = {}) {
  // $FlowExpectedError[incompatible-type]
  const detachedNode = { ...props,
    ...((config == null ? void 0 : config.preserveLocation) !== true ? {
      // if this is [0,0] AND the file has a docblock then prettier will insert newlines between
      // certain detached nodes. Because of "intended" formatting behaviour (https://github.com/prettier/prettier/issues/12078)
      // this can cause us to output weirdly formatted code that should have been collapsed.
      //
      // prettier works backwards from the position you give it to find newlines or non whitespace
      // tokens and uses this to determine if newlines should be inserted between nodes.
      // By placing the range at [1, 1] we can ensure a token is always found before a newline
      // and therefore no newlines will be placed between nodes.
      //
      // NOTE: we will still run into the bug if there is weird code like a docblock with whitespace
      //       characters before it. However we assume this isn't going to happen because any file
      //       already formatted by prettier will have that whitespace removed.
      // We considered a more complex solution involving traversing the AST and manually updating
      // detached node ranges after mutations are applied - however this is a lot heavier and will
      // probably never be needed.
      range: [1, 1],
      loc: {
        start: {
          line: 1,
          column: 0
        },
        end: {
          line: 1,
          column: 0
        }
      }
    } : {}),
    // if not provided, then we purposely don't set this here
    // and will rely on the tooling to update it as appropriate.
    // nothing should be reading from this before it's set anyway.
    parent: parent
  }; // mark the node as detached

  Object.defineProperty(detachedNode, DETACHED_MARKER, {
    configurable: false,
    enumerable: false,
    value: true,
    writable: false
  });

  if (config.originalNode) {
    Object.defineProperty(detachedNode, ORIGINAL_NODE, {
      configurable: false,
      enumerable: false,
      value: config.originalNode,
      writable: false
    });
  }

  return detachedNode;
}
/**
 * Shallowly clones the node, but not its children.
 */


function shallowCloneNode(node, newProps, config = {}) {
  var _config$preserveLocat, _config$originalNode;

  return detachedProps(null, // $FlowFixMe[cannot-spread-interface]
  { ...node,
    ...newProps
  }, {
    preserveLocation: (_config$preserveLocat = config.preserveLocation) != null ? _config$preserveLocat : true,
    originalNode: (_config$originalNode = config.originalNode) != null ? _config$originalNode : node
  });
}
/**
 * Deeply clones node and its entire tree.
 */


function deepCloneNode(node, newProps) {
  const clone = Object.assign(JSON.parse(JSON.stringify(node, (key, value) => {
    // null out parent pointers
    if (key === 'parent') {
      return undefined;
    }

    return value;
  })), newProps);
  updateAllParentPointers(clone); // $FlowExpectedError[class-object-subtyping]

  return detachedProps(null, clone);
}
/**
 * Corrects the parent pointers in direct children of the given node
 */


function setParentPointersInDirectChildren(node) {
  _hermesParser.astNodeMutationHelpers.setParentPointersInDirectChildren(node);
}
/**
 * Traverses the entire subtree to ensure the parent pointers are set correctly
 */


function updateAllParentPointers(node) {
  _hermesParser.astNodeMutationHelpers.updateAllParentPointers(node);
}
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CommentPlacement = void 0;
exports.addComment = addComment;
exports.addCommentsToNode = addCommentsToNode;
exports.appendCommentToSource = appendCommentToSource;
exports.attachComments = attachComments;
exports.cloneComment = cloneComment;
exports.cloneCommentWithMarkers = cloneCommentWithMarkers;
exports.cloneJSDocCommentsToNewNode = cloneJSDocCommentsToNewNode;
exports.getCommentsForNode = getCommentsForNode;
exports.getLeadingCommentsForNode = getLeadingCommentsForNode;
exports.getTrailingCommentsForNode = getTrailingCommentsForNode;
exports.isLeadingComment = isLeadingComment;
exports.isTrailingComment = isTrailingComment;
exports.makeCommentOwnLine = makeCommentOwnLine;
exports.moveCommentsToNewNode = moveCommentsToNewNode;
exports.setCommentsOnNode = setCommentsOnNode;

var _comments = require("./prettier/main/comments");

var _loc = require("./prettier/language-js/loc");

var _printerEstree = _interopRequireDefault(require("./prettier/language-js/printer-estree"));

var _util = require("./prettier/common/util");

var _hermesEstree = require("hermes-estree");

var _os = require("os");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// $FlowExpectedError[untyped-import]
// $FlowExpectedError[untyped-import]
// $FlowExpectedError[untyped-import]
const CommentPlacement = require("flow-enums-runtime").Mirrored(["LEADING_OWN_LINE", "LEADING_INLINE", "TRAILING_OWN_LINE", "TRAILING_INLINE"]);

exports.CommentPlacement = CommentPlacement;

function attachComments(comments, ast, text) {
  (0, _comments.attach)(comments, ast, text, {
    locStart: _loc.locStart,
    locEnd: _loc.locEnd,
    printer: _printerEstree.default
  });
}

function moveCommentsToNewNode(oldNode, newNode) {
  setCommentsOnNode(newNode, getCommentsForNode(oldNode));
  setCommentsOnNode(oldNode, []);
}

function cloneJSDocCommentsToNewNode(oldNode, newNode) {
  const comments = getCommentsForNode(oldNode).filter(comment => {
    return (0, _hermesEstree.isBlockComment)(comment) && // JSDoc comments always start with an extra asterisk
    comment.value.startsWith('*');
  });
  setCommentsOnNode(newNode, [...getCommentsForNode(newNode), ...comments.map(cloneCommentWithMarkers)]);
}

function setCommentsOnNode(node, comments) {
  // $FlowExpectedError - this property is secretly added by prettier.
  node.comments = comments;
}

function addCommentsToNode(node, comments, side = 'trailing') {
  var _node$comments;

  // $FlowExpectedError[prop-missing] - this property is secretly added by prettier.
  // $FlowExpectedError[cannot-write]
  // $FlowExpectedError[incompatible-use]
  node.comments = (_node$comments = node.comments) != null ? _node$comments : [];

  if (side === 'leading') {
    // $FlowExpectedError[incompatible-cast]
    node.comments.unshift(...comments);
  } else {
    // $FlowExpectedError[incompatible-cast]
    node.comments.push(...comments);
  }
}

function getCommentsForNode(node) {
  var _node$comments2;

  // $FlowExpectedError - this property is secretly added by prettier.
  return (_node$comments2 = node.comments) != null ? _node$comments2 : [];
}

function isLeadingComment(comment) {
  // $FlowExpectedError - this property is secretly added by prettier.
  return comment.leading === true;
}

function isTrailingComment(comment) {
  // $FlowExpectedError - this property is secretly added by prettier.
  return comment.trailing === true;
}

function getLeadingCommentsForNode(node) {
  return getCommentsForNode(node).filter(isLeadingComment);
}

function getTrailingCommentsForNode(node) {
  return getCommentsForNode(node).filter(isTrailingComment);
}

function addComment(node, comment, placement) {
  switch (placement) {
    case CommentPlacement.LEADING_OWN_LINE:
    case CommentPlacement.LEADING_INLINE:
      {
        (0, _util.addLeadingComment)(node, comment);
        break;
      }

    case CommentPlacement.TRAILING_OWN_LINE:
    case CommentPlacement.TRAILING_INLINE:
      {
        (0, _util.addTrailingComment)(node, comment);
        break;
      }
  }
}

function cloneComment(comment) {
  // $FlowExpectedError[incompatible-return]
  return {
    type: comment.type,
    value: comment.value,
    loc: comment.loc,
    range: comment.range
  };
}

function cloneCommentWithMarkers(comment) {
  // $FlowExpectedError[incompatible-return]
  return {
    type: comment.type,
    value: comment.value,
    loc: comment.loc,
    range: comment.range,
    leading: isLeadingComment(comment),
    trailing: isTrailingComment(comment)
  };
}

function getFirstNewlineIndex(code) {
  return code.search(/\r\n|\n|\r/);
}

function getFirstNonWhitespaceIndex(code) {
  return code.search(/\S/);
}

function makeCommentOwnLine(code, comment) {
  let newCode = code; // Since we always want a line break we need to ensure a newline is found when
  // searching out from either side of the comment range.

  let firstNewline = getFirstNewlineIndex(code);

  if (firstNewline === -1) {
    // No newline in file, lets add one.
    newCode += _os.EOL;
    firstNewline = newCode.length;
  } // Prettier only uses these ranges for detecting whitespace, so this nonsensical
  // range is safe.
  // $FlowExpectedError[cannot-write]


  comment.range = [firstNewline + 1, firstNewline];
  return newCode;
}

function appendCommentToSource(code, comment, placement) {
  let newCode = code;

  switch (comment.type) {
    case 'Block':
      {
        // Prettier decides if a newline is necessary between the comment and its node by looking
        // to see if a newline seperates them in the source text. We can trick prettier into
        // formatting how we want for new comments by placing the range such that a newline
        // will (OWN_LINE) or will not (INLINE) be found when searching from the specified range
        // position.
        switch (placement) {
          case CommentPlacement.LEADING_OWN_LINE:
          case CommentPlacement.TRAILING_OWN_LINE:
            {
              newCode = makeCommentOwnLine(code, comment);
              break;
            }

          case CommentPlacement.LEADING_INLINE:
          case CommentPlacement.TRAILING_INLINE:
            {
              // Since we don't want a line break we need to ensure a non whitespace char is
              // always found before a newline when searching out from either side of the
              // comment range.
              let firstNonWhitespace = getFirstNonWhitespaceIndex(code);

              if (firstNonWhitespace === -1) {
                // No non whitespace chars in file, lets add an identifiable statement for prettier to find.
                newCode += '$FORCE_INLINE_ON_EMPTY_FILE_TOKEN$;';
                firstNonWhitespace = newCode.length;
                break;
              } // $FlowExpectedError[cannot-write]


              comment.range = [firstNonWhitespace + 1, firstNonWhitespace];
              break;
            }
        }

        break;
      }

    case 'Line':
      {
        // For `Line` comments prettier slices comments directly from the source code when printing
        // https://github.com/prettier/prettier/blob/5f0ee39fa03532c85bd1c35291450fe7ac3667b3/src/language-js/print/comment.js#L15-L20
        // this means that we need to have any appended comments directly in the
        // source code or else prettier will slice nothing and bork up the transform
        const commentText = `//${comment.value}`;
        const lastChar = newCode[newCode.length - 1];

        if (lastChar !== '\n' && lastChar !== '\r') {
          newCode += _os.EOL;
        } // Line comments cannot be inline before a node so we only place trailing Line comments inline.


        if (placement === CommentPlacement.TRAILING_INLINE) {
          // Prettier determines an "end of line" comment by walking backwards from
          // the comment start range through the source code to see if it finds a non
          // newline token. In order to trick prettier for new comments we need to
          // insert fake source code for it to find.
          newCode += '$FORCE_END_OF_LINE_COMMENT_TOKEN$;';
        }

        const start = newCode.length;
        newCode += commentText;
        const end = newCode.length; // $FlowExpectedError[cannot-write]

        comment.range = [start, end];
        break;
      }
  }

  return newCode;
}
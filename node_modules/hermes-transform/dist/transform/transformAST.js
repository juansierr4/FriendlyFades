/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformAST = transformAST;

var _detachedNode = require("../detachedNode");

var _traverse = require("../traverse/traverse");

var _MutationContext = require("./MutationContext");

var _TransformContext = require("./TransformContext");

var _AddComments = require("./mutations/AddComments");

var _CloneCommentsTo = require("./mutations/CloneCommentsTo");

var _InsertStatement = require("./mutations/InsertStatement");

var _RemoveComment = require("./mutations/RemoveComment");

var _RemoveNode = require("./mutations/RemoveNode");

var _RemoveStatement = require("./mutations/RemoveStatement");

var _ReplaceNode = require("./mutations/ReplaceNode");

var _ReplaceStatementWithMany = require("./mutations/ReplaceStatementWithMany");

function transformAST({
  ast,
  scopeManager,
  code
}, visitors) {
  // traverse the AST and collect the mutations
  const transformContext = (0, _TransformContext.getTransformContext)();
  (0, _traverse.traverseWithContext)(code, ast, scopeManager, () => transformContext, visitors); // apply the mutations to the AST

  const mutationContext = new _MutationContext.MutationContext(code);
  const removeCommentMutations = [];

  for (const mutation of transformContext.mutations) {
    const mutationRoot = (() => {
      switch (mutation.type) {
        case 'insertStatement':
          {
            return (0, _InsertStatement.performInsertStatementMutation)(mutationContext, mutation);
          }

        case 'replaceNode':
          {
            return (0, _ReplaceNode.performReplaceNodeMutation)(mutationContext, mutation);
          }

        case 'replaceStatementWithMany':
          {
            return (0, _ReplaceStatementWithMany.performReplaceStatementWithManyMutation)(mutationContext, mutation);
          }

        case 'removeNode':
          {
            return (0, _RemoveNode.performRemoveNodeMutation)(mutationContext, mutation);
          }

        case 'removeStatement':
          {
            return (0, _RemoveStatement.performRemoveStatementMutation)(mutationContext, mutation);
          }

        case 'removeComment':
          {
            // these are handled later
            removeCommentMutations.push(mutation);
            return null;
          }

        case 'addComments':
          {
            return (0, _AddComments.performAddCommentsMutation)(mutationContext, mutation);
          }

        case 'cloneCommentsTo':
          {
            return (0, _CloneCommentsTo.performCloneCommentsToMutation)(mutationContext, mutation);
          }
      }
    })(); // ensure the subtree's parent pointers are correct
    // this is required for two reasons:
    // 1) The userland transform is just JS - so there's nothing stopping them
    //    from doing anything dodgy. The flow types have some enforcement, but
    //    ofc that can just be ignored with a suppression.
    // 2) Shallow clones are a necessary evil in the transform because they
    //    allow codemods to do simple changes to just one node without the
    //    weight that comes with deeply cloning the entire AST.
    //    However we can't update the parent pointers of the cloned node's
    //    children until the mutation step or else we would be mutating
    //    real AST nodes and potentially break the traverse step.
    //
    // Being strict here just helps us ensure we keep everything in sync


    if (mutationRoot) {
      (0, _detachedNode.updateAllParentPointers)(mutationRoot);
    }
  } // remove the comments
  // this is done at the end because it requires a complete traversal of the AST
  // so that we can find relevant node's attachment array


  (0, _RemoveComment.performRemoveCommentMutations)(ast, removeCommentMutations);
  return {
    ast,
    astWasMutated: transformContext.astWasMutated,
    mutatedCode: mutationContext.code
  };
}
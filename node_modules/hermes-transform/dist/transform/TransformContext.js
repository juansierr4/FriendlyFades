"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTransformContext = getTransformContext;

var _detachedNode = require("../detachedNode");

var _comments = require("./comments/comments");

var _AddComments = require("./mutations/AddComments");

var _CloneCommentsTo = require("./mutations/CloneCommentsTo");

var _InsertStatement = require("./mutations/InsertStatement");

var _RemoveComment = require("./mutations/RemoveComment");

var _RemoveNode = require("./mutations/RemoveNode");

var _RemoveStatement = require("./mutations/RemoveStatement");

var _ReplaceNode = require("./mutations/ReplaceNode");

var _ReplaceStatementWithMany = require("./mutations/ReplaceStatementWithMany");

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
function getTransformContext() {
  /**
   * The mutations in order of collection.
   */
  const mutations = [];

  function pushMutation(mutation) {
    if (mutation != null) {
      mutations.push(mutation);
    }
  }

  const cloneAPIs = {
    // $FlowFixMe[incompatible-exact]
    shallowCloneNode: node => {
      if (node == null) {
        return null;
      }

      return (0, _detachedNode.shallowCloneNode)(node, {});
    },
    shallowCloneNodeWithOverrides: (node, newProps = {}) => {
      if (node == null) {
        return null;
      }

      return (0, _detachedNode.shallowCloneNode)(node, newProps);
    },
    // $FlowFixMe[incompatible-exact]
    shallowCloneArray: nodes => {
      if (nodes == null) {
        return null;
      }

      return nodes.map(node => {
        if (node == null) {
          // $FlowExpectedError[incompatible-return]
          return node;
        }

        return (0, _detachedNode.shallowCloneNode)(node, {});
      });
    },
    // $FlowFixMe[incompatible-exact]
    deepCloneNode: node => {
      if (node == null) {
        return null;
      }

      return (0, _detachedNode.deepCloneNode)(node, {});
    },
    deepCloneNodeWithOverrides: (node, newProps = {}) => {
      if (node == null) {
        return null;
      }

      return (0, _detachedNode.deepCloneNode)(node, newProps);
    }
  };
  const commentAPIs = {
    getComments: node => {
      return [...(0, _comments.getCommentsForNode)(node)];
    },
    getLeadingComments: node => {
      return (0, _comments.getCommentsForNode)(node).filter(_comments.isLeadingComment);
    },
    getTrailingComments: node => {
      return (0, _comments.getCommentsForNode)(node).filter(_comments.isTrailingComment);
    },
    cloneCommentsTo: (target, destination) => {
      pushMutation((0, _CloneCommentsTo.createCloneCommentsToMutation)(target, destination));
    },
    addLeadingComments: (node, comments) => {
      pushMutation((0, _AddComments.createAddCommentsMutation)(node, toArray(comments).map(comment => ({
        comment,
        placement: _comments.CommentPlacement.LEADING_OWN_LINE
      }))));
    },
    addLeadingInlineComments: (node, comments) => {
      pushMutation((0, _AddComments.createAddCommentsMutation)(node, toArray(comments).map(comment => ({
        comment,
        placement: _comments.CommentPlacement.LEADING_INLINE
      }))));
    },
    addTrailingComments: (node, comments) => {
      pushMutation((0, _AddComments.createAddCommentsMutation)(node, toArray(comments).map(comment => ({
        comment,
        placement: _comments.CommentPlacement.TRAILING_OWN_LINE
      }))));
    },
    addTrailingInlineComments: (node, comments) => {
      pushMutation((0, _AddComments.createAddCommentsMutation)(node, toArray(comments).map(comment => ({
        comment,
        placement: _comments.CommentPlacement.TRAILING_INLINE
      }))));
    },
    removeComments: comments => {
      toArray(comments).forEach(comment => {
        pushMutation((0, _RemoveComment.createRemoveCommentMutation)(comment));
      });
    }
  };
  const insertAPIs = {
    insertAfterStatement: (target, nodesToInsert) => {
      pushMutation((0, _InsertStatement.createInsertStatementMutation)('after', target, toArray(nodesToInsert).map(n => (0, _detachedNode.asDetachedNode)(n, {
        useDeepClone: true
      }))));
    },
    insertBeforeStatement: (target, nodesToInsert) => {
      pushMutation((0, _InsertStatement.createInsertStatementMutation)('before', target, toArray(nodesToInsert).map(n => (0, _detachedNode.asDetachedNode)(n, {
        useDeepClone: true
      }))));
    }
  };
  const removeAPIs = {
    removeNode: node => {
      pushMutation((0, _RemoveNode.createRemoveNodeMutation)(node));
    },
    removeStatement: node => {
      pushMutation((0, _RemoveStatement.createRemoveStatementMutation)(node));
    }
  };
  const replaceAPIs = {
    // $FlowFixMe[incompatible-exact]
    replaceNode: (target, nodeToReplaceWith, options) => {
      pushMutation((0, _ReplaceNode.createReplaceNodeMutation)(target, (0, _detachedNode.asDetachedNode)(nodeToReplaceWith), options));
    },
    replaceStatementWithMany: (target, nodesToReplaceWith, options) => {
      pushMutation((0, _ReplaceStatementWithMany.createReplaceStatementWithManyMutation)(target, nodesToReplaceWith.map(n => (0, _detachedNode.asDetachedNode)(n)), options));
    }
  };
  const modifyAPIs = {
    modifyNodeInPlace: (node, newProps = {}, options) => {
      if (node == null) {
        return;
      }

      const cloned = (0, _detachedNode.shallowCloneNode)(node, newProps, {
        preserveLocation: true
      }); // $FlowExpectedError[incompatible-call]

      replaceAPIs.replaceNode(node, cloned, options);
    }
  };
  return {
    mutations,

    // $FlowExpectedError[unsafe-getters-setters]
    get astWasMutated() {
      return mutations.length > 0;
    },

    ...cloneAPIs,
    ...commentAPIs,
    ...insertAPIs,
    ...modifyAPIs,
    ...removeAPIs,
    ...replaceAPIs
  };
}

function toArray(thing) {
  if (Array.isArray(thing)) {
    // $FlowExpectedError[incompatible-return]
    return thing;
  }

  return [thing];
}
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createInsertStatementMutation = createInsertStatementMutation;
exports.performInsertStatementMutation = performInsertStatementMutation;

var _hermesParser = require("hermes-parser");

var _getStatementParent = require("./utils/getStatementParent");

var _isValidModuleDeclarationParent = require("./utils/isValidModuleDeclarationParent");

var _Errors = require("../Errors");

var t = _interopRequireWildcard(require("../../generated/node-types"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
function createInsertStatementMutation(side, target, nodesToInsert) {
  if (nodesToInsert.length === 0) {
    return null;
  }

  return {
    type: 'insertStatement',
    side,
    target,
    nodesToInsert
  };
}

function performInsertStatementMutation(mutationContext, mutation) {
  mutationContext.assertNotDeleted(mutation.target, `Attempted to insert ${mutation.side} a deleted ${mutation.target.type} node. This likely means that you attempted to mutate around the target after it was deleted/replaced.`);
  const insertionParent = (0, _getStatementParent.getStatementParent)(mutation.target); // enforce that if we are inserting module declarations - they are being inserted in a valid location

  if (!(0, _isValidModuleDeclarationParent.isValidModuleDeclarationParent)(insertionParent.parent, mutation.nodesToInsert)) {
    throw new _Errors.InvalidInsertionError(`import/export cannot be inserted into a ${insertionParent.parent.type}.`);
  }

  mutationContext.markMutation(insertionParent.parent, insertionParent.key);

  if (insertionParent.type === 'array') {
    const parent = insertionParent.parent;

    switch (mutation.side) {
      case 'before':
        {
          parent[insertionParent.key] = _hermesParser.astArrayMutationHelpers.insertInArray(parent[insertionParent.key], insertionParent.targetIndex, mutation.nodesToInsert);
          break;
        }

      case 'after':
        {
          parent[insertionParent.key] = _hermesParser.astArrayMutationHelpers.insertInArray(parent[insertionParent.key], insertionParent.targetIndex + 1, mutation.nodesToInsert);
          break;
        }
    }

    return insertionParent.parent;
  }

  const statementsToInsert = // $FlowExpectedError[incompatible-cast] -- this is enforced by isValidModuleDeclarationParent above
  mutation.nodesToInsert;
  const {
    parent,
    key
  } = insertionParent; // $FlowExpectedError[prop-missing]

  const statementToWrap = parent[key]; // we need to wrap this key in a BlockStatement so we can insert the new statement

  const blockStatement = t.BlockStatement({
    body: mutation.side === 'before' ? [...statementsToInsert, statementToWrap] : [statementToWrap, ...statementsToInsert],
    parent: insertionParent.parent
  });
  insertionParent.parent[insertionParent.key] = blockStatement;
  statementToWrap.parent = blockStatement;
  return insertionParent.parent;
}
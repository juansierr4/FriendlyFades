"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getStatementParent = getStatementParent;

var _Errors = require("../../Errors");

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
function getStatementParent(target) {
  function assertValidStatementLocation(parentWithType, ...invalidKeys) {
    for (const key of invalidKeys) {
      // $FlowExpectedError[prop-missing]
      const value = parentWithType[key];

      if (value === target || Array.isArray(value) && value.includes(target)) {
        throw new _Errors.InvalidStatementError(`Attempted to insert a statement into \`${parentWithType.type}.${key}\`.`);
      }
    }
  }

  function getAssertedIndex(key, arr) {
    const idx = arr.indexOf(target);

    if (idx === -1) {
      throw new _Errors.InvalidStatementError(`Could not find target in array of \`${parent.type}.${key}\`.`);
    }

    return idx;
  }

  const parent = target.parent;

  const result = (() => {
    switch (parent.type) {
      case 'IfStatement':
        {
          assertValidStatementLocation(parent, 'test');
          const key = parent.consequent === target ? 'consequent' : 'alternate';
          return {
            type: 'single',
            parent,
            key
          };
        }

      case 'LabeledStatement':
        {
          assertValidStatementLocation(parent, 'label');
          return {
            type: 'single',
            parent,
            key: 'body'
          };
        }

      case 'WithStatement':
        {
          assertValidStatementLocation(parent, 'object');
          return {
            type: 'single',
            parent,
            key: 'body'
          };
        }

      case 'DoWhileStatement':
      case 'WhileStatement':
        {
          assertValidStatementLocation(parent, 'test');
          return {
            type: 'single',
            parent,
            key: 'body'
          };
        }

      case 'ForStatement':
        {
          assertValidStatementLocation(parent, 'init', 'test', 'update');
          return {
            type: 'single',
            parent,
            key: 'body'
          };
        }

      case 'ForInStatement':
      case 'ForOfStatement':
        {
          assertValidStatementLocation(parent, // $FlowExpectedError[prop-missing] - flow does not track properties from parent interface
          'left', // $FlowExpectedError[prop-missing] - flow does not track properties from parent interface
          'right');
          return {
            type: 'single',
            parent,
            key: 'body'
          };
        }

      case 'SwitchCase':
        {
          assertValidStatementLocation(parent, 'test');
          return {
            type: 'array',
            parent,
            key: 'consequent',
            targetIndex: getAssertedIndex('consequent', parent.consequent)
          };
        }

      case 'BlockStatement':
      case 'Program':
        {
          return {
            type: 'array',
            parent,
            key: 'body',
            targetIndex: getAssertedIndex('body', parent.body)
          };
        }
    }

    throw new _Errors.InvalidStatementError(`Expected to find a valid statement parent, but found a parent of type "${parent.type}".`);
  })();

  if ( // array insertions are already validated by the getAssertedIndex function
  result.targetIndex == null && // $FlowExpectedError[prop-missing]
  result.parent[result.key] !== target) {
    throw new _Errors.InvalidStatementError(`Expected to find the target "${target.type}" on the "${result.parent.type}.${result.key}", but found a different node. ` + 'This likely means that you attempted to mutate around the target after it was deleted/replaced.');
  }

  return result;
}
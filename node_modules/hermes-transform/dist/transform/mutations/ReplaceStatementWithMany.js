"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createReplaceStatementWithManyMutation = createReplaceStatementWithManyMutation;
exports.performReplaceStatementWithManyMutation = performReplaceStatementWithManyMutation;

var _hermesParser = require("hermes-parser");

var _getStatementParent = require("./utils/getStatementParent");

var _isValidModuleDeclarationParent = require("./utils/isValidModuleDeclarationParent");

var _comments = require("../comments/comments");

var _Errors = require("../Errors");

var t = _interopRequireWildcard(require("../../generated/node-types"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
function createReplaceStatementWithManyMutation(target, nodesToReplaceWith, options) {
  var _options$keepComments;

  if (nodesToReplaceWith.length === 0) {
    return null;
  }

  return {
    type: 'replaceStatementWithMany',
    target,
    nodesToReplaceWith,
    keepComments: (_options$keepComments = options == null ? void 0 : options.keepComments) != null ? _options$keepComments : false
  };
}

function performReplaceStatementWithManyMutation(mutationContext, mutation) {
  const replacementParent = (0, _getStatementParent.getStatementParent)(mutation.target); // enforce that if we are replacing with module declarations - they are being inserted in a valid location

  if (!(0, _isValidModuleDeclarationParent.isValidModuleDeclarationParent)(replacementParent.parent, mutation.nodesToReplaceWith)) {
    throw new _Errors.InvalidReplacementError(`import/export cannot be replaced into a ${replacementParent.parent.type}.`);
  }

  mutationContext.markDeletion(mutation.target);
  mutationContext.markMutation(replacementParent.parent, replacementParent.key);

  if (mutation.keepComments) {
    // attach comments to the very first replacement node
    (0, _comments.moveCommentsToNewNode)(mutation.target, mutation.nodesToReplaceWith[0]);
  }

  if (replacementParent.type === 'array') {
    const parent = replacementParent.parent;
    parent[replacementParent.key] = _hermesParser.astArrayMutationHelpers.replaceInArray(parent[replacementParent.key], replacementParent.targetIndex, mutation.nodesToReplaceWith);
    return replacementParent.parent;
  }

  const statementsToReplaceWith = // $FlowExpectedError[incompatible-cast] -- this is enforced by isValidModuleDeclarationParent above
  mutation.nodesToReplaceWith; // we need to wrap the nodes in a BlockStatement as before there was only 1 node

  const blockStatement = t.BlockStatement({
    body: statementsToReplaceWith,
    parent: replacementParent.parent
  });
  replacementParent.parent[replacementParent.key] = blockStatement;
  return replacementParent.parent;
}
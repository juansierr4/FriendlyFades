"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createReplaceNodeMutation = createReplaceNodeMutation;
exports.performReplaceNodeMutation = performReplaceNodeMutation;

var _hermesParser = require("hermes-parser");

var _comments = require("../comments/comments");

var _Errors = require("../Errors");

var _detachedNode = require("../../detachedNode");

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
function createReplaceNodeMutation(target, nodeToReplaceWith, options) {
  var _options$keepComments;

  return {
    type: 'replaceNode',
    target,
    nodeToReplaceWith,
    keepComments: (_options$keepComments = options == null ? void 0 : options.keepComments) != null ? _options$keepComments : false
  };
}

function performReplaceNodeMutation(mutationContext, mutation) {
  const replacementParent = getParentKey(mutation.target);
  mutationContext.markDeletion(mutation.target);
  mutationContext.markMutation(replacementParent.parent, replacementParent.key); // NOTE: currently this mutation assumes you're doing the right thing.
  // it does no runtime checks and provides no guarantees about the
  // correctness of the resulting code.
  // TODO: maybe add some runtime checks based on codegenned predicates?

  if (replacementParent.type === 'array') {
    const parent = replacementParent.parent;
    parent[replacementParent.key] = _hermesParser.astArrayMutationHelpers.replaceInArray(parent[replacementParent.key], replacementParent.targetIndex, [mutation.nodeToReplaceWith]);
  } else {
    replacementParent.parent[replacementParent.key] = mutation.nodeToReplaceWith;
  }

  if (mutation.keepComments) {
    (0, _comments.moveCommentsToNewNode)(mutation.target, mutation.nodeToReplaceWith);
  }

  return replacementParent.parent;
}

function getParentKey(target) {
  const parent = target.parent;

  for (const key of (0, _hermesParser.getVisitorKeys)(parent)) {
    if ((0, _hermesParser.isNode)( // $FlowExpectedError[prop-missing]
    parent[key])) {
      if (parent[key] === target) {
        return {
          type: 'single',
          parent,
          key
        };
      }
    } else if (Array.isArray(parent[key])) {
      for (let i = 0; i < parent[key].length; i += 1) {
        const current = parent[key][i];
        const originalNode = (0, _detachedNode.getOriginalNode)(current);

        if (current === target || originalNode === target) {
          return {
            type: 'array',
            parent,
            key,
            targetIndex: i
          };
        }
      }
    }
  } // this shouldn't happen ever


  throw new _Errors.InvalidReplacementError(`Expected to find the ${target.type} as a direct child of the ${parent.type}.`);
}
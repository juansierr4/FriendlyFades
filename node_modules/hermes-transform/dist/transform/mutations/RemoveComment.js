"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRemoveCommentMutation = createRemoveCommentMutation;
exports.performRemoveCommentMutations = performRemoveCommentMutations;

var _hermesParser = require("hermes-parser");

var _comments = require("../comments/comments");

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
function createRemoveCommentMutation(comment) {
  return {
    type: 'removeComment',
    comment
  };
}

function performRemoveCommentMutations(ast, mutations) {
  if (mutations.length === 0) {
    return;
  }

  const commentsToRemove = new Set(mutations.map(m => m.comment));

  _hermesParser.SimpleTraverser.traverse(ast, {
    enter(node) {
      if (node === ast) {
        return;
      }

      const nodeCommentsSet = new Set((0, _comments.getCommentsForNode)(node));

      if (nodeCommentsSet.size === 0) {
        return;
      }

      const matchedComments = intersectSets(commentsToRemove, nodeCommentsSet);

      for (const comment of matchedComments) {
        commentsToRemove.delete(comment);
        nodeCommentsSet.delete(comment);
      }

      (0, _comments.setCommentsOnNode)(node, Array.from(nodeCommentsSet));

      if (commentsToRemove.size === 0) {
        // no more comments to process - so we can exit traversal
        throw _hermesParser.SimpleTraverserBreak;
      }
    },

    leave() {}

  });
}

function intersectSets(first, other) {
  const ret = new Set();

  for (const value of first) {
    if (other.has(value)) {
      ret.add(value);
    }
  }

  return ret;
}
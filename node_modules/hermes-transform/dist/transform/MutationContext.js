"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MutationContext = void 0;

var _Errors = require("./Errors");

var _comments = require("./comments/comments");

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
class MutationContext {
  // TODO - do we care about this? Arrays are pretty safe to concurrently mutate
  constructor(code) {
    this._deletedNodes = new Set();
    this._mutatedKeys = new Map();
    this._mutatedArrays = new Map();
    this.code = void 0;
    this.code = code;
  }
  /**
   * Marks a node and its entire subtree as deleted.
   */


  markDeletion(node) {
    this._deletedNodes.add(node);
  }
  /**
   * Marks the key of the node as having been mutated.
   */


  markMutation(node, key) {
    var _map$get$add, _map$get;

    this.assertNotDeleted(node, `Attempted to mutate a \`${node.type}.${key}\` on a deleted node.`);
    this.assertNotMutated(node, key, `Attempted to mutate a \`${node.type}.${key}\` when it has already been mutated.`);
    const map = Array.isArray( // $FlowExpectedError[prop-missing]
    node[key]) ? this._mutatedArrays : this._mutatedKeys;
    map.set(node, (_map$get$add = (_map$get = map.get(node)) == null ? void 0 : _map$get.add(key)) != null ? _map$get$add : new Set([key]));
  }
  /**
   * Throws if the node has been deleted
   */


  assertNotDeleted(node, message) {
    if (this._deletedNodes.has(node)) {
      throw new _Errors.NodeIsDeletedError(message);
    }
  }
  /**
   * Throws if the key of the node has been mutated
   */


  assertNotMutated(node, key, message) {
    var _this$_mutatedKeys$ge;

    if (((_this$_mutatedKeys$ge = this._mutatedKeys.get(node)) == null ? void 0 : _this$_mutatedKeys$ge.has(key)) === true) {
      throw new _Errors.NodeIsMutatedError(message);
    }
  }

  appendCommentToSource(comment, placement) {
    this.code = (0, _comments.appendCommentToSource)(this.code, comment, placement);
  }

}

exports.MutationContext = MutationContext;
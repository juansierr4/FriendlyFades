"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrowFunctionExpression = ArrowFunctionExpression;
exports.ClassDeclaration = ClassDeclaration;
exports.DeclareFunction = DeclareFunction;
exports.Identifier = Identifier;
exports.MemberExpression = MemberExpression;
exports.Program = Program;
exports.TemplateElement = TemplateElement;

var _detachedNode = require("../../detachedNode");

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
function ArrowFunctionExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ArrowFunctionExpression',
    id: null,
    // $FlowExpectedError[incompatible-use]
    expression: props.body.type !== 'BlockStatement',
    params: props.params.map(n => (0, _detachedNode.asDetachedNode)(n)),
    body: (0, _detachedNode.asDetachedNode)(props.body),
    // $FlowFixMe[incompatible-call]
    typeParameters: (0, _detachedNode.asDetachedNode)(props.typeParameters),
    // $FlowFixMe[incompatible-call]
    returnType: (0, _detachedNode.asDetachedNode)(props.returnType),
    // $FlowFixMe[incompatible-call]
    predicate: (0, _detachedNode.asDetachedNode)(props.predicate),
    async: props.async
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ClassDeclaration(props) {
  var _props$decorators, _props$implements;

  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ClassDeclaration',
    // $FlowFixMe[incompatible-call]
    id: (0, _detachedNode.asDetachedNode)(props.id),
    // $FlowFixMe[incompatible-call]
    typeParameters: (0, _detachedNode.asDetachedNode)(props.typeParameters),
    // $FlowFixMe[incompatible-call]
    superClass: (0, _detachedNode.asDetachedNode)(props.superClass),
    // $FlowFixMe[incompatible-call]
    superTypeParameters: (0, _detachedNode.asDetachedNode)(props.superTypeParameters),
    decorators: ((_props$decorators = props.decorators) != null ? _props$decorators : []).map(n => (0, _detachedNode.asDetachedNode)(n)),
    implements: ((_props$implements = props.implements) != null ? _props$implements : []).map(n => (0, _detachedNode.asDetachedNode)(n)),
    body: (0, _detachedNode.asDetachedNode)(props.body)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
} // raw/cooked are on a subobject in the estree spec, but are flat on the hermes types


function TemplateElement(props) {
  return (0, _detachedNode.detachedProps)(props.parent, {
    type: 'TemplateElement',
    tail: props.tail,
    value: {
      cooked: props.cooked,
      raw: props.raw
    }
  });
} // Identifier has a bunch of stuff that usually you don't want to provide - so we have
// this manual def to allow us to default some values


function Identifier(props) {
  var _props$optional;

  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'Identifier',
    name: props.name,
    optional: (_props$optional = props.optional) != null ? _props$optional : false,
    // $FlowFixMe[incompatible-call]
    typeAnnotation: (0, _detachedNode.asDetachedNode)(props.typeAnnotation)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function Program(props) {
  return (0, _detachedNode.detachedProps)(null, {
    type: 'Program',
    sourceType: props.sourceType,
    body: props.body.map(n => (0, _detachedNode.asDetachedNode)(n)),
    tokens: props.tokens,
    comments: props.comments,
    interpreter: props.interpreter != null ? // $FlowFixMe[incompatible-call]
    (0, _detachedNode.asDetachedNode)({
      type: 'InterpreterDirective',
      value: props.interpreter
    }) : null,
    docblock: props.docblock
  });
} // the type annotation is stored on the Identifier's typeAnnotation
// which is super awkward to work with and type - so we flatten the input
// and put it in the right spot after


function DeclareFunction(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'DeclareFunction',
    id: (0, _detachedNode.detachedProps)(null, {
      type: 'Identifier',
      name: props.name,
      typeAnnotation: (0, _detachedNode.detachedProps)(null, {
        type: 'TypeAnnotation',
        typeAnnotation: (0, _detachedNode.asDetachedNode)(props.functionType)
      })
    }),
    // $FlowFixMe[incompatible-call]
    predicate: (0, _detachedNode.asDetachedNode)(props.predicate)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function MemberExpression(props) {
  var _props$optional2;

  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'MemberExpression',
    object: (0, _detachedNode.asDetachedNode)(props.object),
    property: (0, _detachedNode.asDetachedNode)(props.property),
    computed: props.computed,
    optional: (_props$optional2 = props.optional) != null ? _props$optional2 : false
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectTypeAccessorSignature = ObjectTypeAccessorSignature;
exports.ObjectTypeMethodSignature = ObjectTypeMethodSignature;
exports.ObjectTypePropertySignature = ObjectTypePropertySignature;

var _detachedNode = require("../../detachedNode");

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
function ObjectTypeMethodSignature(props) {
  var _props$proto, _props$static;

  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ObjectTypeProperty',
    key: (0, _detachedNode.asDetachedNode)(props.key),
    kind: 'init',
    method: true,
    optional: false,
    proto: (_props$proto = props.proto) != null ? _props$proto : false,
    static: (_props$static = props.static) != null ? _props$static : false,
    value: (0, _detachedNode.asDetachedNode)(props.value),
    variance: null
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ObjectTypePropertySignature(props) {
  var _props$proto2, _props$static2;

  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ObjectTypeProperty',
    key: (0, _detachedNode.asDetachedNode)(props.key),
    kind: 'init',
    method: false,
    optional: props.optional,
    proto: (_props$proto2 = props.proto) != null ? _props$proto2 : false,
    static: (_props$static2 = props.static) != null ? _props$static2 : false,
    value: (0, _detachedNode.asDetachedNode)(props.value),
    // $FlowFixMe[incompatible-call]
    variance: (0, _detachedNode.asDetachedNode)(props.variance)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ObjectTypeAccessorSignature(props) {
  var _props$proto3, _props$static3;

  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ObjectTypeProperty',
    key: (0, _detachedNode.asDetachedNode)(props.key),
    kind: props.kind,
    method: false,
    optional: false,
    proto: (_props$proto3 = props.proto) != null ? _props$proto3 : false,
    static: (_props$static3 = props.static) != null ? _props$static3 : false,
    value: (0, _detachedNode.asDetachedNode)(props.value),
    variance: null
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}
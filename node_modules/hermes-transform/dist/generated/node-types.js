/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @generated
 */

/*
 * !!! GENERATED FILE !!!
 *
 * Any manual changes to this file will be overwritten. To regenerate run `yarn build`.
 */
// lint directives to let us do some basic validation of generated files

/* eslint no-undef: 'error', no-unused-vars: ['error', {vars: "local"}], no-redeclare: 'error' */

/* global $NonMaybeType, Partial, $ReadOnly, $ReadOnlyArray */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  AnyTypeAnnotation: true,
  ArrayExpression: true,
  ArrayPattern: true,
  ArrayTypeAnnotation: true,
  AsExpression: true,
  AssignmentExpression: true,
  AssignmentPattern: true,
  AwaitExpression: true,
  BigIntLiteralTypeAnnotation: true,
  BigIntTypeAnnotation: true,
  BinaryExpression: true,
  BlockStatement: true,
  BooleanLiteralTypeAnnotation: true,
  BooleanTypeAnnotation: true,
  BreakStatement: true,
  CallExpression: true,
  CatchClause: true,
  ChainExpression: true,
  ClassBody: true,
  ClassExpression: true,
  ClassImplements: true,
  ComponentDeclaration: true,
  ComponentParameter: true,
  ComponentTypeAnnotation: true,
  ComponentTypeParameter: true,
  ConditionalExpression: true,
  ConditionalTypeAnnotation: true,
  ContinueStatement: true,
  DebuggerStatement: true,
  DeclareClass: true,
  DeclareComponent: true,
  DeclaredPredicate: true,
  DeclareEnum: true,
  DeclareExportAllDeclaration: true,
  DeclareInterface: true,
  DeclareModule: true,
  DeclareModuleExports: true,
  DeclareOpaqueType: true,
  DeclareTypeAlias: true,
  DeclareVariable: true,
  DoWhileStatement: true,
  EmptyStatement: true,
  EmptyTypeAnnotation: true,
  EnumBooleanBody: true,
  EnumBooleanMember: true,
  EnumDeclaration: true,
  EnumDefaultedMember: true,
  EnumNumberBody: true,
  EnumNumberMember: true,
  EnumStringBody: true,
  EnumStringMember: true,
  EnumSymbolBody: true,
  ExistsTypeAnnotation: true,
  ExportAllDeclaration: true,
  ExportDefaultDeclaration: true,
  ExportSpecifier: true,
  ExpressionStatement: true,
  ForInStatement: true,
  ForOfStatement: true,
  ForStatement: true,
  FunctionDeclaration: true,
  FunctionExpression: true,
  FunctionTypeAnnotation: true,
  FunctionTypeParam: true,
  GenericTypeAnnotation: true,
  IfStatement: true,
  ImportAttribute: true,
  ImportDeclaration: true,
  ImportDefaultSpecifier: true,
  ImportExpression: true,
  ImportNamespaceSpecifier: true,
  ImportSpecifier: true,
  IndexedAccessType: true,
  InferredPredicate: true,
  InferTypeAnnotation: true,
  InterfaceDeclaration: true,
  InterfaceExtends: true,
  InterfaceTypeAnnotation: true,
  IntersectionTypeAnnotation: true,
  JSXAttribute: true,
  JSXClosingElement: true,
  JSXClosingFragment: true,
  JSXElement: true,
  JSXEmptyExpression: true,
  JSXExpressionContainer: true,
  JSXFragment: true,
  JSXIdentifier: true,
  JSXMemberExpression: true,
  JSXNamespacedName: true,
  JSXOpeningElement: true,
  JSXOpeningFragment: true,
  JSXSpreadAttribute: true,
  JSXSpreadChild: true,
  JSXText: true,
  KeyofTypeAnnotation: true,
  LabeledStatement: true,
  LogicalExpression: true,
  MetaProperty: true,
  MethodDefinition: true,
  MixedTypeAnnotation: true,
  NewExpression: true,
  NullableTypeAnnotation: true,
  NullLiteralTypeAnnotation: true,
  NumberLiteralTypeAnnotation: true,
  NumberTypeAnnotation: true,
  ObjectExpression: true,
  ObjectPattern: true,
  ObjectTypeAnnotation: true,
  ObjectTypeCallProperty: true,
  ObjectTypeIndexer: true,
  ObjectTypeInternalSlot: true,
  ObjectTypeMappedTypeProperty: true,
  ObjectTypeSpreadProperty: true,
  OpaqueType: true,
  OptionalIndexedAccessType: true,
  PrivateIdentifier: true,
  Property: true,
  PropertyDefinition: true,
  QualifiedTypeIdentifier: true,
  QualifiedTypeofIdentifier: true,
  RestElement: true,
  ReturnStatement: true,
  SequenceExpression: true,
  SpreadElement: true,
  StringLiteralTypeAnnotation: true,
  StringTypeAnnotation: true,
  Super: true,
  SwitchCase: true,
  SwitchStatement: true,
  SymbolTypeAnnotation: true,
  TaggedTemplateExpression: true,
  TemplateLiteral: true,
  ThisExpression: true,
  ThisTypeAnnotation: true,
  ThrowStatement: true,
  TryStatement: true,
  TupleTypeAnnotation: true,
  TupleTypeLabeledElement: true,
  TupleTypeSpreadElement: true,
  TypeAlias: true,
  TypeAnnotation: true,
  TypeCastExpression: true,
  TypeofTypeAnnotation: true,
  TypeOperator: true,
  TypeParameter: true,
  TypeParameterDeclaration: true,
  TypeParameterInstantiation: true,
  TypePredicate: true,
  UnaryExpression: true,
  UnionTypeAnnotation: true,
  UpdateExpression: true,
  VariableDeclaration: true,
  VariableDeclarator: true,
  Variance: true,
  VoidTypeAnnotation: true,
  WhileStatement: true,
  WithStatement: true,
  YieldExpression: true
};
exports.AnyTypeAnnotation = AnyTypeAnnotation;
exports.ArrayExpression = ArrayExpression;
exports.ArrayPattern = ArrayPattern;
exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
exports.AsExpression = AsExpression;
exports.AssignmentExpression = AssignmentExpression;
exports.AssignmentPattern = AssignmentPattern;
exports.AwaitExpression = AwaitExpression;
exports.BigIntLiteralTypeAnnotation = BigIntLiteralTypeAnnotation;
exports.BigIntTypeAnnotation = BigIntTypeAnnotation;
exports.BinaryExpression = BinaryExpression;
exports.BlockStatement = BlockStatement;
exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
exports.BreakStatement = BreakStatement;
exports.CallExpression = CallExpression;
exports.CatchClause = CatchClause;
exports.ChainExpression = ChainExpression;
exports.ClassBody = ClassBody;
exports.ClassExpression = ClassExpression;
exports.ClassImplements = ClassImplements;
exports.ComponentDeclaration = ComponentDeclaration;
exports.ComponentParameter = ComponentParameter;
exports.ComponentTypeAnnotation = ComponentTypeAnnotation;
exports.ComponentTypeParameter = ComponentTypeParameter;
exports.ConditionalExpression = ConditionalExpression;
exports.ConditionalTypeAnnotation = ConditionalTypeAnnotation;
exports.ContinueStatement = ContinueStatement;
exports.DebuggerStatement = DebuggerStatement;
exports.DeclareClass = DeclareClass;
exports.DeclareComponent = DeclareComponent;
exports.DeclareEnum = DeclareEnum;
exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
exports.DeclareInterface = DeclareInterface;
exports.DeclareModule = DeclareModule;
exports.DeclareModuleExports = DeclareModuleExports;
exports.DeclareOpaqueType = DeclareOpaqueType;
exports.DeclareTypeAlias = DeclareTypeAlias;
exports.DeclareVariable = DeclareVariable;
exports.DeclaredPredicate = DeclaredPredicate;
exports.DoWhileStatement = DoWhileStatement;
exports.EmptyStatement = EmptyStatement;
exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
exports.EnumBooleanBody = EnumBooleanBody;
exports.EnumBooleanMember = EnumBooleanMember;
exports.EnumDeclaration = EnumDeclaration;
exports.EnumDefaultedMember = EnumDefaultedMember;
exports.EnumNumberBody = EnumNumberBody;
exports.EnumNumberMember = EnumNumberMember;
exports.EnumStringBody = EnumStringBody;
exports.EnumStringMember = EnumStringMember;
exports.EnumSymbolBody = EnumSymbolBody;
exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
exports.ExportAllDeclaration = ExportAllDeclaration;
exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
exports.ExportSpecifier = ExportSpecifier;
exports.ExpressionStatement = ExpressionStatement;
exports.ForInStatement = ForInStatement;
exports.ForOfStatement = ForOfStatement;
exports.ForStatement = ForStatement;
exports.FunctionDeclaration = FunctionDeclaration;
exports.FunctionExpression = FunctionExpression;
exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
exports.FunctionTypeParam = FunctionTypeParam;
exports.GenericTypeAnnotation = GenericTypeAnnotation;
exports.IfStatement = IfStatement;
exports.ImportAttribute = ImportAttribute;
exports.ImportDeclaration = ImportDeclaration;
exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
exports.ImportExpression = ImportExpression;
exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
exports.ImportSpecifier = ImportSpecifier;
exports.IndexedAccessType = IndexedAccessType;
exports.InferTypeAnnotation = InferTypeAnnotation;
exports.InferredPredicate = InferredPredicate;
exports.InterfaceDeclaration = InterfaceDeclaration;
exports.InterfaceExtends = InterfaceExtends;
exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
exports.JSXAttribute = JSXAttribute;
exports.JSXClosingElement = JSXClosingElement;
exports.JSXClosingFragment = JSXClosingFragment;
exports.JSXElement = JSXElement;
exports.JSXEmptyExpression = JSXEmptyExpression;
exports.JSXExpressionContainer = JSXExpressionContainer;
exports.JSXFragment = JSXFragment;
exports.JSXIdentifier = JSXIdentifier;
exports.JSXMemberExpression = JSXMemberExpression;
exports.JSXNamespacedName = JSXNamespacedName;
exports.JSXOpeningElement = JSXOpeningElement;
exports.JSXOpeningFragment = JSXOpeningFragment;
exports.JSXSpreadAttribute = JSXSpreadAttribute;
exports.JSXSpreadChild = JSXSpreadChild;
exports.JSXText = JSXText;
exports.KeyofTypeAnnotation = KeyofTypeAnnotation;
exports.LabeledStatement = LabeledStatement;
exports.LogicalExpression = LogicalExpression;
exports.MetaProperty = MetaProperty;
exports.MethodDefinition = MethodDefinition;
exports.MixedTypeAnnotation = MixedTypeAnnotation;
exports.NewExpression = NewExpression;
exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
exports.NullableTypeAnnotation = NullableTypeAnnotation;
exports.NumberLiteralTypeAnnotation = NumberLiteralTypeAnnotation;
exports.NumberTypeAnnotation = NumberTypeAnnotation;
exports.ObjectExpression = ObjectExpression;
exports.ObjectPattern = ObjectPattern;
exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
exports.ObjectTypeIndexer = ObjectTypeIndexer;
exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
exports.ObjectTypeMappedTypeProperty = ObjectTypeMappedTypeProperty;
exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
exports.OpaqueType = OpaqueType;
exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
exports.PrivateIdentifier = PrivateIdentifier;
exports.Property = Property;
exports.PropertyDefinition = PropertyDefinition;
exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
exports.QualifiedTypeofIdentifier = QualifiedTypeofIdentifier;
exports.RestElement = RestElement;
exports.ReturnStatement = ReturnStatement;
exports.SequenceExpression = SequenceExpression;
exports.SpreadElement = SpreadElement;
exports.StringLiteralTypeAnnotation = StringLiteralTypeAnnotation;
exports.StringTypeAnnotation = StringTypeAnnotation;
exports.Super = Super;
exports.SwitchCase = SwitchCase;
exports.SwitchStatement = SwitchStatement;
exports.SymbolTypeAnnotation = SymbolTypeAnnotation;
exports.TaggedTemplateExpression = TaggedTemplateExpression;
exports.TemplateLiteral = TemplateLiteral;
exports.ThisExpression = ThisExpression;
exports.ThisTypeAnnotation = ThisTypeAnnotation;
exports.ThrowStatement = ThrowStatement;
exports.TryStatement = TryStatement;
exports.TupleTypeAnnotation = TupleTypeAnnotation;
exports.TupleTypeLabeledElement = TupleTypeLabeledElement;
exports.TupleTypeSpreadElement = TupleTypeSpreadElement;
exports.TypeAlias = TypeAlias;
exports.TypeAnnotation = TypeAnnotation;
exports.TypeCastExpression = TypeCastExpression;
exports.TypeOperator = TypeOperator;
exports.TypeParameter = TypeParameter;
exports.TypeParameterDeclaration = TypeParameterDeclaration;
exports.TypeParameterInstantiation = TypeParameterInstantiation;
exports.TypePredicate = TypePredicate;
exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
exports.UnaryExpression = UnaryExpression;
exports.UnionTypeAnnotation = UnionTypeAnnotation;
exports.UpdateExpression = UpdateExpression;
exports.VariableDeclaration = VariableDeclaration;
exports.VariableDeclarator = VariableDeclarator;
exports.Variance = Variance;
exports.VoidTypeAnnotation = VoidTypeAnnotation;
exports.WhileStatement = WhileStatement;
exports.WithStatement = WithStatement;
exports.YieldExpression = YieldExpression;

var _detachedNode = require("../detachedNode");

var _specialCaseNodeTypes = require("./special-case-node-types");

Object.keys(_specialCaseNodeTypes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _specialCaseNodeTypes[key]) return;
  exports[key] = _specialCaseNodeTypes[key];
});

function AnyTypeAnnotation(props = { ...null
}) {
  return (0, _detachedNode.detachedProps)(props.parent, {
    type: 'AnyTypeAnnotation'
  });
}

function ArrayExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ArrayExpression',
    elements: props.elements.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    trailingComma: props.trailingComma
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ArrayPattern(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ArrayPattern',
    elements: props.elements.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    typeAnnotation: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeAnnotation)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ArrayTypeAnnotation(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ArrayTypeAnnotation',
    elementType: (0, _detachedNode.asDetachedNodeForCodeGen)(props.elementType)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function AsExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'AsExpression',
    expression: (0, _detachedNode.asDetachedNodeForCodeGen)(props.expression),
    typeAnnotation: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeAnnotation)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function AssignmentExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'AssignmentExpression',
    operator: props.operator,
    left: (0, _detachedNode.asDetachedNodeForCodeGen)(props.left),
    right: (0, _detachedNode.asDetachedNodeForCodeGen)(props.right)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function AssignmentPattern(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'AssignmentPattern',
    left: (0, _detachedNode.asDetachedNodeForCodeGen)(props.left),
    right: (0, _detachedNode.asDetachedNodeForCodeGen)(props.right)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function AwaitExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'AwaitExpression',
    argument: (0, _detachedNode.asDetachedNodeForCodeGen)(props.argument)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function BigIntLiteralTypeAnnotation(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'BigIntLiteralTypeAnnotation',
    raw: props.raw
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function BigIntTypeAnnotation(props = { ...null
}) {
  return (0, _detachedNode.detachedProps)(props.parent, {
    type: 'BigIntTypeAnnotation'
  });
}

function BinaryExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'BinaryExpression',
    left: (0, _detachedNode.asDetachedNodeForCodeGen)(props.left),
    right: (0, _detachedNode.asDetachedNodeForCodeGen)(props.right),
    operator: props.operator
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function BlockStatement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'BlockStatement',
    body: props.body.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n))
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function BooleanLiteralTypeAnnotation(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'BooleanLiteralTypeAnnotation',
    value: props.value,
    raw: props.raw
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function BooleanTypeAnnotation(props = { ...null
}) {
  return (0, _detachedNode.detachedProps)(props.parent, {
    type: 'BooleanTypeAnnotation'
  });
}

function BreakStatement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'BreakStatement',
    label: (0, _detachedNode.asDetachedNodeForCodeGen)(props.label)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function CallExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'CallExpression',
    callee: (0, _detachedNode.asDetachedNodeForCodeGen)(props.callee),
    typeArguments: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeArguments),
    arguments: props.arguments.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n))
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function CatchClause(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'CatchClause',
    param: (0, _detachedNode.asDetachedNodeForCodeGen)(props.param),
    body: (0, _detachedNode.asDetachedNodeForCodeGen)(props.body)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ChainExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ChainExpression',
    expression: (0, _detachedNode.asDetachedNodeForCodeGen)(props.expression)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ClassBody(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ClassBody',
    body: props.body.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n))
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ClassExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ClassExpression',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    typeParameters: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeParameters),
    superClass: (0, _detachedNode.asDetachedNodeForCodeGen)(props.superClass),
    superTypeParameters: (0, _detachedNode.asDetachedNodeForCodeGen)(props.superTypeParameters),
    implements: props.implements.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    decorators: props.decorators.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    body: (0, _detachedNode.asDetachedNodeForCodeGen)(props.body)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ClassImplements(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ClassImplements',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    typeParameters: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeParameters)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ComponentDeclaration(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ComponentDeclaration',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    params: props.params.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    body: (0, _detachedNode.asDetachedNodeForCodeGen)(props.body),
    typeParameters: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeParameters),
    rendersType: (0, _detachedNode.asDetachedNodeForCodeGen)(props.rendersType)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ComponentParameter(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ComponentParameter',
    name: (0, _detachedNode.asDetachedNodeForCodeGen)(props.name),
    local: (0, _detachedNode.asDetachedNodeForCodeGen)(props.local),
    shorthand: props.shorthand
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ComponentTypeAnnotation(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ComponentTypeAnnotation',
    params: props.params.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    rest: (0, _detachedNode.asDetachedNodeForCodeGen)(props.rest),
    typeParameters: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeParameters),
    rendersType: (0, _detachedNode.asDetachedNodeForCodeGen)(props.rendersType)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ComponentTypeParameter(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ComponentTypeParameter',
    name: (0, _detachedNode.asDetachedNodeForCodeGen)(props.name),
    typeAnnotation: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeAnnotation),
    optional: props.optional
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ConditionalExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ConditionalExpression',
    test: (0, _detachedNode.asDetachedNodeForCodeGen)(props.test),
    alternate: (0, _detachedNode.asDetachedNodeForCodeGen)(props.alternate),
    consequent: (0, _detachedNode.asDetachedNodeForCodeGen)(props.consequent)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ConditionalTypeAnnotation(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ConditionalTypeAnnotation',
    checkType: (0, _detachedNode.asDetachedNodeForCodeGen)(props.checkType),
    extendsType: (0, _detachedNode.asDetachedNodeForCodeGen)(props.extendsType),
    trueType: (0, _detachedNode.asDetachedNodeForCodeGen)(props.trueType),
    falseType: (0, _detachedNode.asDetachedNodeForCodeGen)(props.falseType)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ContinueStatement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ContinueStatement',
    label: (0, _detachedNode.asDetachedNodeForCodeGen)(props.label)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function DebuggerStatement(props = { ...null
}) {
  return (0, _detachedNode.detachedProps)(props.parent, {
    type: 'DebuggerStatement'
  });
}

function DeclareClass(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'DeclareClass',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    typeParameters: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeParameters),
    extends: props.extends.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    implements: props.implements.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    mixins: props.mixins.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    body: (0, _detachedNode.asDetachedNodeForCodeGen)(props.body)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function DeclareComponent(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'DeclareComponent',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    params: props.params.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    rest: (0, _detachedNode.asDetachedNodeForCodeGen)(props.rest),
    typeParameters: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeParameters),
    rendersType: (0, _detachedNode.asDetachedNodeForCodeGen)(props.rendersType)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function DeclaredPredicate(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'DeclaredPredicate',
    value: (0, _detachedNode.asDetachedNodeForCodeGen)(props.value)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function DeclareEnum(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'DeclareEnum',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    body: (0, _detachedNode.asDetachedNodeForCodeGen)(props.body)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function DeclareExportAllDeclaration(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'DeclareExportAllDeclaration',
    source: (0, _detachedNode.asDetachedNodeForCodeGen)(props.source)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function DeclareInterface(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'DeclareInterface',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    typeParameters: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeParameters),
    extends: props.extends.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    body: (0, _detachedNode.asDetachedNodeForCodeGen)(props.body)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function DeclareModule(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'DeclareModule',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    body: (0, _detachedNode.asDetachedNodeForCodeGen)(props.body),
    kind: props.kind
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function DeclareModuleExports(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'DeclareModuleExports',
    typeAnnotation: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeAnnotation)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function DeclareOpaqueType(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'DeclareOpaqueType',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    typeParameters: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeParameters),
    impltype: (0, _detachedNode.asDetachedNodeForCodeGen)(props.impltype),
    supertype: (0, _detachedNode.asDetachedNodeForCodeGen)(props.supertype)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function DeclareTypeAlias(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'DeclareTypeAlias',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    typeParameters: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeParameters),
    right: (0, _detachedNode.asDetachedNodeForCodeGen)(props.right)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function DeclareVariable(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'DeclareVariable',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    kind: props.kind
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function DoWhileStatement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'DoWhileStatement',
    body: (0, _detachedNode.asDetachedNodeForCodeGen)(props.body),
    test: (0, _detachedNode.asDetachedNodeForCodeGen)(props.test)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function EmptyStatement(props = { ...null
}) {
  return (0, _detachedNode.detachedProps)(props.parent, {
    type: 'EmptyStatement'
  });
}

function EmptyTypeAnnotation(props = { ...null
}) {
  return (0, _detachedNode.detachedProps)(props.parent, {
    type: 'EmptyTypeAnnotation'
  });
}

function EnumBooleanBody(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'EnumBooleanBody',
    members: props.members.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    explicitType: props.explicitType,
    hasUnknownMembers: props.hasUnknownMembers
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function EnumBooleanMember(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'EnumBooleanMember',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    init: (0, _detachedNode.asDetachedNodeForCodeGen)(props.init)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function EnumDeclaration(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'EnumDeclaration',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    body: (0, _detachedNode.asDetachedNodeForCodeGen)(props.body)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function EnumDefaultedMember(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'EnumDefaultedMember',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function EnumNumberBody(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'EnumNumberBody',
    members: props.members.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    explicitType: props.explicitType,
    hasUnknownMembers: props.hasUnknownMembers
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function EnumNumberMember(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'EnumNumberMember',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    init: (0, _detachedNode.asDetachedNodeForCodeGen)(props.init)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function EnumStringBody(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'EnumStringBody',
    members: props.members.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    explicitType: props.explicitType,
    hasUnknownMembers: props.hasUnknownMembers
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function EnumStringMember(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'EnumStringMember',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    init: (0, _detachedNode.asDetachedNodeForCodeGen)(props.init)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function EnumSymbolBody(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'EnumSymbolBody',
    members: props.members.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    hasUnknownMembers: props.hasUnknownMembers
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ExistsTypeAnnotation(props = { ...null
}) {
  return (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ExistsTypeAnnotation'
  });
}

function ExportAllDeclaration(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ExportAllDeclaration',
    exported: (0, _detachedNode.asDetachedNodeForCodeGen)(props.exported),
    source: (0, _detachedNode.asDetachedNodeForCodeGen)(props.source),
    exportKind: props.exportKind
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ExportDefaultDeclaration(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ExportDefaultDeclaration',
    declaration: (0, _detachedNode.asDetachedNodeForCodeGen)(props.declaration)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ExportSpecifier(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ExportSpecifier',
    exported: (0, _detachedNode.asDetachedNodeForCodeGen)(props.exported),
    local: (0, _detachedNode.asDetachedNodeForCodeGen)(props.local)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ExpressionStatement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ExpressionStatement',
    expression: (0, _detachedNode.asDetachedNodeForCodeGen)(props.expression),
    directive: props.directive
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ForInStatement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ForInStatement',
    left: (0, _detachedNode.asDetachedNodeForCodeGen)(props.left),
    right: (0, _detachedNode.asDetachedNodeForCodeGen)(props.right),
    body: (0, _detachedNode.asDetachedNodeForCodeGen)(props.body)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ForOfStatement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ForOfStatement',
    left: (0, _detachedNode.asDetachedNodeForCodeGen)(props.left),
    right: (0, _detachedNode.asDetachedNodeForCodeGen)(props.right),
    body: (0, _detachedNode.asDetachedNodeForCodeGen)(props.body),
    await: props.await
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ForStatement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ForStatement',
    init: (0, _detachedNode.asDetachedNodeForCodeGen)(props.init),
    test: (0, _detachedNode.asDetachedNodeForCodeGen)(props.test),
    update: (0, _detachedNode.asDetachedNodeForCodeGen)(props.update),
    body: (0, _detachedNode.asDetachedNodeForCodeGen)(props.body)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function FunctionDeclaration(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'FunctionDeclaration',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    params: props.params.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    body: (0, _detachedNode.asDetachedNodeForCodeGen)(props.body),
    typeParameters: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeParameters),
    returnType: (0, _detachedNode.asDetachedNodeForCodeGen)(props.returnType),
    predicate: (0, _detachedNode.asDetachedNodeForCodeGen)(props.predicate),
    generator: props.generator,
    async: props.async
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function FunctionExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'FunctionExpression',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    params: props.params.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    body: (0, _detachedNode.asDetachedNodeForCodeGen)(props.body),
    typeParameters: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeParameters),
    returnType: (0, _detachedNode.asDetachedNodeForCodeGen)(props.returnType),
    predicate: (0, _detachedNode.asDetachedNodeForCodeGen)(props.predicate),
    generator: props.generator,
    async: props.async
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function FunctionTypeAnnotation(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'FunctionTypeAnnotation',
    params: props.params.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    this: (0, _detachedNode.asDetachedNodeForCodeGen)(props.this),
    returnType: (0, _detachedNode.asDetachedNodeForCodeGen)(props.returnType),
    rest: (0, _detachedNode.asDetachedNodeForCodeGen)(props.rest),
    typeParameters: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeParameters)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function FunctionTypeParam(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'FunctionTypeParam',
    name: (0, _detachedNode.asDetachedNodeForCodeGen)(props.name),
    typeAnnotation: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeAnnotation),
    optional: props.optional
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function GenericTypeAnnotation(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'GenericTypeAnnotation',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    typeParameters: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeParameters)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function IfStatement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'IfStatement',
    test: (0, _detachedNode.asDetachedNodeForCodeGen)(props.test),
    consequent: (0, _detachedNode.asDetachedNodeForCodeGen)(props.consequent),
    alternate: (0, _detachedNode.asDetachedNodeForCodeGen)(props.alternate)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ImportAttribute(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ImportAttribute',
    key: (0, _detachedNode.asDetachedNodeForCodeGen)(props.key),
    value: (0, _detachedNode.asDetachedNodeForCodeGen)(props.value)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ImportDeclaration(props) {
  var _props$assertions;

  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ImportDeclaration',
    specifiers: props.specifiers.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    source: (0, _detachedNode.asDetachedNodeForCodeGen)(props.source),
    assertions: (_props$assertions = props.assertions) == null ? void 0 : _props$assertions.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    importKind: props.importKind
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ImportDefaultSpecifier(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ImportDefaultSpecifier',
    local: (0, _detachedNode.asDetachedNodeForCodeGen)(props.local)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ImportExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ImportExpression',
    source: (0, _detachedNode.asDetachedNodeForCodeGen)(props.source),
    attributes: (0, _detachedNode.asDetachedNodeForCodeGen)(props.attributes)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ImportNamespaceSpecifier(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ImportNamespaceSpecifier',
    local: (0, _detachedNode.asDetachedNodeForCodeGen)(props.local)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ImportSpecifier(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ImportSpecifier',
    imported: (0, _detachedNode.asDetachedNodeForCodeGen)(props.imported),
    local: (0, _detachedNode.asDetachedNodeForCodeGen)(props.local),
    importKind: props.importKind
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function IndexedAccessType(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'IndexedAccessType',
    objectType: (0, _detachedNode.asDetachedNodeForCodeGen)(props.objectType),
    indexType: (0, _detachedNode.asDetachedNodeForCodeGen)(props.indexType)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function InferredPredicate(props = { ...null
}) {
  return (0, _detachedNode.detachedProps)(props.parent, {
    type: 'InferredPredicate'
  });
}

function InferTypeAnnotation(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'InferTypeAnnotation',
    typeParameter: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeParameter)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function InterfaceDeclaration(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'InterfaceDeclaration',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    typeParameters: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeParameters),
    extends: props.extends.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    body: (0, _detachedNode.asDetachedNodeForCodeGen)(props.body)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function InterfaceExtends(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'InterfaceExtends',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    typeParameters: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeParameters)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function InterfaceTypeAnnotation(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'InterfaceTypeAnnotation',
    extends: props.extends.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    body: (0, _detachedNode.asDetachedNodeForCodeGen)(props.body)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function IntersectionTypeAnnotation(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'IntersectionTypeAnnotation',
    types: props.types.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n))
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function JSXAttribute(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'JSXAttribute',
    name: (0, _detachedNode.asDetachedNodeForCodeGen)(props.name),
    value: (0, _detachedNode.asDetachedNodeForCodeGen)(props.value)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function JSXClosingElement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'JSXClosingElement',
    name: (0, _detachedNode.asDetachedNodeForCodeGen)(props.name)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function JSXClosingFragment(props = { ...null
}) {
  return (0, _detachedNode.detachedProps)(props.parent, {
    type: 'JSXClosingFragment'
  });
}

function JSXElement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'JSXElement',
    openingElement: (0, _detachedNode.asDetachedNodeForCodeGen)(props.openingElement),
    children: props.children.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    closingElement: (0, _detachedNode.asDetachedNodeForCodeGen)(props.closingElement)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function JSXEmptyExpression(props = { ...null
}) {
  return (0, _detachedNode.detachedProps)(props.parent, {
    type: 'JSXEmptyExpression'
  });
}

function JSXExpressionContainer(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'JSXExpressionContainer',
    expression: (0, _detachedNode.asDetachedNodeForCodeGen)(props.expression)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function JSXFragment(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'JSXFragment',
    openingFragment: (0, _detachedNode.asDetachedNodeForCodeGen)(props.openingFragment),
    children: props.children.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    closingFragment: (0, _detachedNode.asDetachedNodeForCodeGen)(props.closingFragment)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function JSXIdentifier(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'JSXIdentifier',
    name: props.name
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function JSXMemberExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'JSXMemberExpression',
    object: (0, _detachedNode.asDetachedNodeForCodeGen)(props.object),
    property: (0, _detachedNode.asDetachedNodeForCodeGen)(props.property)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function JSXNamespacedName(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'JSXNamespacedName',
    namespace: (0, _detachedNode.asDetachedNodeForCodeGen)(props.namespace),
    name: (0, _detachedNode.asDetachedNodeForCodeGen)(props.name)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function JSXOpeningElement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'JSXOpeningElement',
    name: (0, _detachedNode.asDetachedNodeForCodeGen)(props.name),
    attributes: props.attributes.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    selfClosing: props.selfClosing,
    typeArguments: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeArguments)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function JSXOpeningFragment(props = { ...null
}) {
  return (0, _detachedNode.detachedProps)(props.parent, {
    type: 'JSXOpeningFragment'
  });
}

function JSXSpreadAttribute(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'JSXSpreadAttribute',
    argument: (0, _detachedNode.asDetachedNodeForCodeGen)(props.argument)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function JSXSpreadChild(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'JSXSpreadChild',
    expression: (0, _detachedNode.asDetachedNodeForCodeGen)(props.expression)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function JSXText(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'JSXText',
    value: props.value,
    raw: props.raw
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function KeyofTypeAnnotation(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'KeyofTypeAnnotation',
    argument: (0, _detachedNode.asDetachedNodeForCodeGen)(props.argument)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function LabeledStatement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'LabeledStatement',
    label: (0, _detachedNode.asDetachedNodeForCodeGen)(props.label),
    body: (0, _detachedNode.asDetachedNodeForCodeGen)(props.body)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function LogicalExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'LogicalExpression',
    left: (0, _detachedNode.asDetachedNodeForCodeGen)(props.left),
    right: (0, _detachedNode.asDetachedNodeForCodeGen)(props.right),
    operator: props.operator
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function MetaProperty(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'MetaProperty',
    meta: (0, _detachedNode.asDetachedNodeForCodeGen)(props.meta),
    property: (0, _detachedNode.asDetachedNodeForCodeGen)(props.property)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function MethodDefinition(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'MethodDefinition',
    key: (0, _detachedNode.asDetachedNodeForCodeGen)(props.key),
    value: (0, _detachedNode.asDetachedNodeForCodeGen)(props.value),
    kind: props.kind,
    computed: props.computed,
    static: props.static
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function MixedTypeAnnotation(props = { ...null
}) {
  return (0, _detachedNode.detachedProps)(props.parent, {
    type: 'MixedTypeAnnotation'
  });
}

function NewExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'NewExpression',
    callee: (0, _detachedNode.asDetachedNodeForCodeGen)(props.callee),
    typeArguments: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeArguments),
    arguments: props.arguments.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n))
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function NullableTypeAnnotation(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'NullableTypeAnnotation',
    typeAnnotation: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeAnnotation)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function NullLiteralTypeAnnotation(props = { ...null
}) {
  return (0, _detachedNode.detachedProps)(props.parent, {
    type: 'NullLiteralTypeAnnotation'
  });
}

function NumberLiteralTypeAnnotation(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'NumberLiteralTypeAnnotation',
    value: props.value,
    raw: props.raw
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function NumberTypeAnnotation(props = { ...null
}) {
  return (0, _detachedNode.detachedProps)(props.parent, {
    type: 'NumberTypeAnnotation'
  });
}

function ObjectExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ObjectExpression',
    properties: props.properties.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n))
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ObjectPattern(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ObjectPattern',
    properties: props.properties.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    typeAnnotation: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeAnnotation)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ObjectTypeAnnotation(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ObjectTypeAnnotation',
    properties: props.properties.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    indexers: props.indexers.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    callProperties: props.callProperties.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    internalSlots: props.internalSlots.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    inexact: props.inexact,
    exact: props.exact
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ObjectTypeCallProperty(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ObjectTypeCallProperty',
    value: (0, _detachedNode.asDetachedNodeForCodeGen)(props.value),
    static: props.static
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ObjectTypeIndexer(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ObjectTypeIndexer',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    key: (0, _detachedNode.asDetachedNodeForCodeGen)(props.key),
    value: (0, _detachedNode.asDetachedNodeForCodeGen)(props.value),
    static: props.static,
    variance: (0, _detachedNode.asDetachedNodeForCodeGen)(props.variance)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ObjectTypeInternalSlot(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ObjectTypeInternalSlot',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    value: (0, _detachedNode.asDetachedNodeForCodeGen)(props.value),
    optional: props.optional,
    static: props.static,
    method: props.method
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ObjectTypeMappedTypeProperty(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ObjectTypeMappedTypeProperty',
    keyTparam: (0, _detachedNode.asDetachedNodeForCodeGen)(props.keyTparam),
    propType: (0, _detachedNode.asDetachedNodeForCodeGen)(props.propType),
    sourceType: (0, _detachedNode.asDetachedNodeForCodeGen)(props.sourceType),
    variance: (0, _detachedNode.asDetachedNodeForCodeGen)(props.variance),
    optional: props.optional
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ObjectTypeSpreadProperty(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ObjectTypeSpreadProperty',
    argument: (0, _detachedNode.asDetachedNodeForCodeGen)(props.argument)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function OpaqueType(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'OpaqueType',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    typeParameters: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeParameters),
    impltype: (0, _detachedNode.asDetachedNodeForCodeGen)(props.impltype),
    supertype: (0, _detachedNode.asDetachedNodeForCodeGen)(props.supertype)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function OptionalIndexedAccessType(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'OptionalIndexedAccessType',
    objectType: (0, _detachedNode.asDetachedNodeForCodeGen)(props.objectType),
    indexType: (0, _detachedNode.asDetachedNodeForCodeGen)(props.indexType),
    optional: props.optional
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function PrivateIdentifier(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'PrivateIdentifier',
    name: props.name
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function Property(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'Property',
    key: (0, _detachedNode.asDetachedNodeForCodeGen)(props.key),
    value: (0, _detachedNode.asDetachedNodeForCodeGen)(props.value),
    kind: props.kind,
    computed: props.computed,
    method: props.method,
    shorthand: props.shorthand
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function PropertyDefinition(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'PropertyDefinition',
    key: (0, _detachedNode.asDetachedNodeForCodeGen)(props.key),
    value: (0, _detachedNode.asDetachedNodeForCodeGen)(props.value),
    computed: props.computed,
    static: props.static,
    declare: props.declare,
    optional: props.optional,
    variance: (0, _detachedNode.asDetachedNodeForCodeGen)(props.variance),
    typeAnnotation: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeAnnotation)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function QualifiedTypeIdentifier(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'QualifiedTypeIdentifier',
    qualification: (0, _detachedNode.asDetachedNodeForCodeGen)(props.qualification),
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function QualifiedTypeofIdentifier(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'QualifiedTypeofIdentifier',
    qualification: (0, _detachedNode.asDetachedNodeForCodeGen)(props.qualification),
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function RestElement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'RestElement',
    argument: (0, _detachedNode.asDetachedNodeForCodeGen)(props.argument)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ReturnStatement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ReturnStatement',
    argument: (0, _detachedNode.asDetachedNodeForCodeGen)(props.argument)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function SequenceExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'SequenceExpression',
    expressions: props.expressions.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n))
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function SpreadElement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'SpreadElement',
    argument: (0, _detachedNode.asDetachedNodeForCodeGen)(props.argument)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function StringLiteralTypeAnnotation(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'StringLiteralTypeAnnotation',
    value: props.value,
    raw: props.raw
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function StringTypeAnnotation(props = { ...null
}) {
  return (0, _detachedNode.detachedProps)(props.parent, {
    type: 'StringTypeAnnotation'
  });
}

function Super(props = { ...null
}) {
  return (0, _detachedNode.detachedProps)(props.parent, {
    type: 'Super'
  });
}

function SwitchCase(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'SwitchCase',
    test: (0, _detachedNode.asDetachedNodeForCodeGen)(props.test),
    consequent: props.consequent.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n))
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function SwitchStatement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'SwitchStatement',
    discriminant: (0, _detachedNode.asDetachedNodeForCodeGen)(props.discriminant),
    cases: props.cases.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n))
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function SymbolTypeAnnotation(props = { ...null
}) {
  return (0, _detachedNode.detachedProps)(props.parent, {
    type: 'SymbolTypeAnnotation'
  });
}

function TaggedTemplateExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'TaggedTemplateExpression',
    tag: (0, _detachedNode.asDetachedNodeForCodeGen)(props.tag),
    quasi: (0, _detachedNode.asDetachedNodeForCodeGen)(props.quasi)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function TemplateLiteral(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'TemplateLiteral',
    quasis: props.quasis.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n)),
    expressions: props.expressions.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n))
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function ThisExpression(props = { ...null
}) {
  return (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ThisExpression'
  });
}

function ThisTypeAnnotation(props = { ...null
}) {
  return (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ThisTypeAnnotation'
  });
}

function ThrowStatement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'ThrowStatement',
    argument: (0, _detachedNode.asDetachedNodeForCodeGen)(props.argument)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function TryStatement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'TryStatement',
    block: (0, _detachedNode.asDetachedNodeForCodeGen)(props.block),
    handler: (0, _detachedNode.asDetachedNodeForCodeGen)(props.handler),
    finalizer: (0, _detachedNode.asDetachedNodeForCodeGen)(props.finalizer)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function TupleTypeAnnotation(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'TupleTypeAnnotation',
    types: props.types.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n))
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function TupleTypeLabeledElement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'TupleTypeLabeledElement',
    label: (0, _detachedNode.asDetachedNodeForCodeGen)(props.label),
    elementType: (0, _detachedNode.asDetachedNodeForCodeGen)(props.elementType),
    optional: props.optional,
    variance: (0, _detachedNode.asDetachedNodeForCodeGen)(props.variance)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function TupleTypeSpreadElement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'TupleTypeSpreadElement',
    label: (0, _detachedNode.asDetachedNodeForCodeGen)(props.label),
    typeAnnotation: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeAnnotation)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function TypeAlias(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'TypeAlias',
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id),
    typeParameters: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeParameters),
    right: (0, _detachedNode.asDetachedNodeForCodeGen)(props.right)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function TypeAnnotation(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'TypeAnnotation',
    typeAnnotation: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeAnnotation)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function TypeCastExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'TypeCastExpression',
    expression: (0, _detachedNode.asDetachedNodeForCodeGen)(props.expression),
    typeAnnotation: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeAnnotation)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function TypeofTypeAnnotation(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'TypeofTypeAnnotation',
    argument: (0, _detachedNode.asDetachedNodeForCodeGen)(props.argument)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function TypeOperator(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'TypeOperator',
    operator: props.operator,
    typeAnnotation: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeAnnotation)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function TypeParameter(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'TypeParameter',
    name: props.name,
    bound: (0, _detachedNode.asDetachedNodeForCodeGen)(props.bound),
    variance: (0, _detachedNode.asDetachedNodeForCodeGen)(props.variance),
    default: (0, _detachedNode.asDetachedNodeForCodeGen)(props.default),
    usesExtendsBound: props.usesExtendsBound
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function TypeParameterDeclaration(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'TypeParameterDeclaration',
    params: props.params.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n))
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function TypeParameterInstantiation(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'TypeParameterInstantiation',
    params: props.params.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n))
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function TypePredicate(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'TypePredicate',
    parameterName: (0, _detachedNode.asDetachedNodeForCodeGen)(props.parameterName),
    typeAnnotation: (0, _detachedNode.asDetachedNodeForCodeGen)(props.typeAnnotation),
    asserts: props.asserts
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function UnaryExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'UnaryExpression',
    operator: props.operator,
    argument: (0, _detachedNode.asDetachedNodeForCodeGen)(props.argument),
    prefix: props.prefix
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function UnionTypeAnnotation(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'UnionTypeAnnotation',
    types: props.types.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n))
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function UpdateExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'UpdateExpression',
    operator: props.operator,
    argument: (0, _detachedNode.asDetachedNodeForCodeGen)(props.argument),
    prefix: props.prefix
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function VariableDeclaration(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'VariableDeclaration',
    kind: props.kind,
    declarations: props.declarations.map(n => (0, _detachedNode.asDetachedNodeForCodeGen)(n))
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function VariableDeclarator(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'VariableDeclarator',
    init: (0, _detachedNode.asDetachedNodeForCodeGen)(props.init),
    id: (0, _detachedNode.asDetachedNodeForCodeGen)(props.id)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function Variance(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'Variance',
    kind: props.kind
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function VoidTypeAnnotation(props = { ...null
}) {
  return (0, _detachedNode.detachedProps)(props.parent, {
    type: 'VoidTypeAnnotation'
  });
}

function WhileStatement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'WhileStatement',
    body: (0, _detachedNode.asDetachedNodeForCodeGen)(props.body),
    test: (0, _detachedNode.asDetachedNodeForCodeGen)(props.test)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function WithStatement(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'WithStatement',
    object: (0, _detachedNode.asDetachedNodeForCodeGen)(props.object),
    body: (0, _detachedNode.asDetachedNodeForCodeGen)(props.body)
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}

function YieldExpression(props) {
  const node = (0, _detachedNode.detachedProps)(props.parent, {
    type: 'YieldExpression',
    argument: (0, _detachedNode.asDetachedNodeForCodeGen)(props.argument),
    delegate: props.delegate
  });
  (0, _detachedNode.setParentPointersInDirectChildren)(node);
  return node;
}